<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021年当我们聊前端部署时，我们在聊什么</title>
      <link href="/2022/06/13/2021%E5%B9%B4%E5%BD%93%E6%88%91%E4%BB%AC%E8%81%8A%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%81%8A%E4%BB%80%E4%B9%88/"/>
      <url>/2022/06/13/2021%E5%B9%B4%E5%BD%93%E6%88%91%E4%BB%AC%E8%81%8A%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%81%8A%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://juejin.cn/post/7017710911443959839" target="_blank" rel="noopener">字节架构前端</a></p></blockquote><h2 id="先上灵魂拷问"><a href="#先上灵魂拷问" class="headerlink" title="先上灵魂拷问"></a>先上灵魂拷问</h2><p>在文章之前，先抛一些灵魂拷问：</p><ul><li>前端代码从 tsx/jsx 到部署上线被用户访问，中间大致会经历哪些过程？</li><li>上述过程中分别都有哪些考虑、指标和优化点，以满足复杂的业务需求？</li><li>可能大部分同学都知道强缓存/协商缓存，那前端各种产物（HTML、JS、CSS、IMAGES 等）应该用什么缓存策略？以及为什么？<ul><li>若使用协商缓存，但静态资源却不频繁更新，如何避免协商过程的请求浪费？</li><li>若使用强缓存，那静态资源如何更新？</li></ul></li></ul><ul><li>配套的，前端静态资源应该如何组织？</li><li>配套的，自动化构建 &amp; 部署过程如何与 CDN 结合？</li><li>如何避免前端上线，影响未刷新页面的用户？</li><li>刚上线的版本发现有阻塞性 bug，如何做到秒级回滚，而非再次部署等 20 分钟甚至更久？</li><li>如何实现一个预发环境，除了前端资源外都是线上环境，将变量控制前端环境内？</li><li>部署环节如何方便配套做 AB 测试等？</li><li>如何实现一套前端代码，发布成多套环境产物？</li><li>如何实现按 feature 发布产物供用户使用，并逐步扩大 feature 灰度，将影响减到最小（即线上同时存在多 feature 产物）？</li><li>CDN 域名突然挂了，如何实现秒级 CDN 降级修补而非再次全部业务重新部署一次？</li></ul><p>本文将会带着这些问题，试着一起探索在2021年，系统化的前端部署解决方案。</p><blockquote><p>PS：本篇关于静态资源组织的问题&amp;思路等，借鉴自知乎大佬张云龙这篇回答 大公司里怎样开发和部署前端代码</p></blockquote><a id="more"></a><h2 id="静态资源组织"><a href="#静态资源组织" class="headerlink" title="静态资源组织"></a>静态资源组织</h2><h3 id="一个简单的页面"><a href="#一个简单的页面" class="headerlink" title="一个简单的页面"></a>一个简单的页面</h3><p>先从简单的静态页面开始，众所周知，前端资源由 <code>HTML</code>、<code>JavaScript</code>、<code>CSS</code> 三剑客组成，假设我们有一个简单的页面，用<code>Nginx</code>作为 Web 服务器，资源组织结构大概如下：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/240634c5beaf49db92713ee281fa98fe_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><p>此时， 只需将 <code>HTML</code>、<code>JavaScript</code>、<code>CSS</code> 等静态资源通过 <code>FTP</code> 等软件，上传到 Web 服务器（如 <code>Nginx</code>）某目录，将 <code>Nginx</code> 启动做简单配置即可让用户访问。</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/0cd65d8a393b4d7abf2f6fe8eddb845f_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><p>用户一访问，状态 200，页面渲染出来，前端十分简单，对不对？</p><h3 id="利用缓存"><a href="#利用缓存" class="headerlink" title="利用缓存"></a>利用缓存</h3><p>但仔细观察，用户每次访问都会请求 <code>foo.css</code>, <code>bar.css</code> 等静态文件，即使该文件并无变更。对带宽甚是浪费，对页面首屏性能等也有影响。于是在网络带宽紧张的互联网早期，计算机先贤们在 <code>HTTP</code> 协议上制定了多种缓存策略。</p><blockquote><p>浏览器缓存：浏览器缓存(<code>Brower Caching</code>)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p></blockquote><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>一种策略是浏览器先问问服务器有没有变化，没变化就用旧资源。毕竟”问一问”的通信成本，远小于每次重新加载资源的成本。大致流程如下：</p><blockquote><p>协商缓存: 向服务器发送请求，服务器会根据这个请求的 <code>Request Header</code> 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 <code>Response Header</code> 通知浏览器从缓存中读取资源；</p></blockquote><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/d0ad7ad5454544cc9f6df1a8d9b7cdfb_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><p>此时，使用协商缓存后，<code>Network</code> 大致变成了这样：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/149bb0b9e97f4032b1bd652d46e3f606_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0%20(1).awebp" alt="image"></p><blockquote><p>注：协商缓存一般可在服务端通过设置 <code>Last-Modified</code>、<code>ETag</code> 等 <code>ResponseHeader</code> 实现。<br>注：304 状态码，表示资源未发生变更，可使用浏览器缓存。</p></blockquote><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>这样，通过协商缓存，我们大幅优化了资源未变更时的网络请求，节约大量带宽，网站首屏性能也有不错的提升，美滋滋！<br>然而仔细观察，发现仍然有协商的过程，一百个静态文件就有一百个协商请求。在资源未发生变更时，追求极致的我们也应该优化掉这个协商请求，毕竟没有买卖就没有伤害！<br>和协商缓存对应的是使用强缓存，大概过程如下：</p><blockquote><p>强缓存：浏览器不会向服务器发送任何请求，直接从本地缓存中读取文件并返回<code>Status Code: 200 OK</code>。</p></blockquote><p>此时，强缓存的大致对话过程如图：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/5ba66dc474384c9488d1485bef852c2a_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><blockquote><p>注意，缓存生效期间，浏览器是【自言自语】，和服务器无关。</p></blockquote><p>此时，设置强缓存后，Network 大致变成了这样：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/60b4eda718ff42d491c2aa788d0cbb42_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><blockquote><p><code>From DiskCache</code>：从硬盘中读取。<br><code>From MemoryCache</code>：从内存中读取，速度最快。<br>注：强缓存一般可在服务端通过设置 <code>Cache-Control: max-age、Expires</code> 等 <code>ResponseHeader</code> 实现。</p></blockquote><p>用上强缓存后，协商的请求也被消灭了，网站加载的性能达到极致了。美滋滋！</p><h4 id="附录：协商缓存和强缓存详解"><a href="#附录：协商缓存和强缓存详解" class="headerlink" title="附录：协商缓存和强缓存详解"></a>附录：协商缓存和强缓存详解</h4><p><a href="https://juejin.cn/post/6844903838768431118" target="_blank" rel="noopener">强缓存/协商缓存详解</a></p><h3 id="缓存更新问题"><a href="#缓存更新问题" class="headerlink" title="缓存更新问题"></a>缓存更新问题</h3><p>鉴于页面（<code>index.html</code>）会频繁更新，而静态资源则相对稳定。所以，我们能推断出的一种缓存策略是 <code>index.html</code> 适合走协商缓存，相对稳定 &amp; 不常更新的静态资源（<code>JS</code>、<code>CSS</code>、<code>IMAGES</code>） 等应该消灭协商请求，使用强缓存。</p><p>然而问题很快就来了，都不让浏览器发请求，但缓存还未到期我们发现有 bug，想更新 <code>foo.css</code> 怎么办？</p><p>又想设置尽量长的时间走缓存，又想要能随时更新？<br>又想马儿跑又不给马儿吃草？</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/4b41a182750b48cfb5df9a5b0ab2b40b_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><p>相信大家很快就能得出一种思路，给资源加版本号！比如通过 <code>query</code> 加版本号，每次上线统一改版本号就搞定了。此时 <code>HTML</code> 变成如图：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/ff668da65572486db031eb113caaaaf1_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><blockquote><p>注意，此时服务器内只有一份文件 <code>foo.css</code> 文件。</p></blockquote><p>统一加版本号的优点是简单粗暴快捷，但缺点则是：假如我们只想更新 <code>foo.css</code>，但 <code>bar.css</code> 缓存也失效了，又造成了带宽的浪费。<br>大家应该很快就能想到办法，需要将文件内容与版本号（<code>URL</code>）绑定，当文件内容发生变更时才变更版本号（<code>URL</code>），这样就能实现每个文件精确的缓存控制。</p><p>什么东西与文件内容相关呢？ <a href="https://www.baike.com/wikiid/1412805162344902915?search_id=3k1jee3i202000&prd=search_sug&view_id=1klgon0vmveo00" target="_blank" rel="noopener">消息摘要算法</a> ，对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据。现在，我们把 <code>URL</code> 改成带文件摘要信息的：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/93a85382a9f14e94b7c889a36f11809d_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><p>我们可以称这种这个方式为 <code>query-hash</code>，后续发版上线时，只有被变更文件的 <code>URL</code> 会更新，实现了精确的缓存控制，完美！</p><blockquote><p>注意，此时服务器内只有一份文件 <code>foo.css</code> 文件。</p></blockquote><h3 id="覆盖式发布引发的问题"><a href="#覆盖式发布引发的问题" class="headerlink" title="覆盖式发布引发的问题"></a>覆盖式发布引发的问题</h3><p>然而假如我们就按上述部署方案就上了线，很快就会 <code>Fatal</code> 满天飞，每次更新上线都可能会出现灾难。</p><p>我们回顾一下，网站的静态文件只有一份，部署在 <code>Nginx</code> 服务器某目录下，并且通过 <code>query-hash</code> 的方式实现按文件做精确缓存控制，问题出在哪了呢？</p><p>回顾一下，我们某次更新时，更改了 <code>foo.css</code> 样式，此时会将 <code>HTML</code> 中的<code>foo.css</code> url更新为最新的 hash，并将服务器中存储的 <code>foo.css</code> &amp; <code>index.html</code> 文件覆盖为最新（V2版本），看似HTML和静态资源都对应更新了，但是没有考虑极端情况。那就是：</p><p>1.<strong>先部署静态资源，部署期间访问时，会出现V1版本HTML访问到V2版本新静态资源，并按V1-hash缓存起来。</strong></p><p>2.<strong>先部署HTML，部署期间访问时，会出现V2版本HTML访问到V1版本旧静态资源，并按V2-hash缓存起来。</strong></p><blockquote><p>如下图所示，展示了不同版本HTML与不同版本静态资源互相匹配到出现的异常Case。</p></blockquote><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/afed5037b76e48caac538b05d4db79b7_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><blockquote><p>绿色走向：正常访问并建立缓存的路径。<br>红色走向：先部署静态资源（V2），V1-HTML访问V2静态资源并缓存Case<br>黑色走向：先部署HTML（V2），V2-HTML访问V1资源并缓存Case</p></blockquote><p>对于问题1，会有两种子Case：</p><p>  1.用户本地有缓存，此时无影响可正常访问。<br>  2.用户本地无缓存，则会将V2版本静态资源加载并按V1版本 hash 缓存起来。用户报错。当V2版本HTML部署完成后，用户再次访问时恢复。</p><p>对于问题2，则会出现严重的Case：</p><p>V2 版本HTML，会将V1版本静态资源按V2版本Hash缓存起来。此时页面会出错，且缓存过期之前会持续报错。直到用户手动清除缓存，或者缓存过期，或者将来发布V3版本更新静态资源版本。否则用户会持续出错。</p><p>上面方案的问题起源于静态资源只有一份，每次发布时都是<code>覆盖式发布</code>，导致页面与静态资源出现匹配错误的情况！解决问题方案也极其简单，使用<code>非覆盖式发布</code>，一种简单的改造方式是将文件摘要（hash）放置到URL 中，即将 <code>query-hash</code> 改为 <code>name-hash</code>。</p><p>此时 HTML 变成如图：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/69518680dfe345d6a4d74b4c00772111_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><p>这样，每次部署时先全量部署静态资源，再灰度部署页面，就能比较完美的解决了缓存的问题。</p><blockquote><p>此时，服务器上会存在多份 <code>foo.[$hash].css</code> 文件</p></blockquote><h3 id="与-CDN-结合"><a href="#与-CDN-结合" class="headerlink" title="与 CDN 结合"></a>与 CDN 结合</h3><p>现在我们开开心心将网站部署上线了，但我们此时仍然将静态资源部署在 <code>Nginx</code> 服务器目录下，然后新的问题来了，随着时间推移，非覆盖部署导致文件逐渐增加多，硬盘逐渐吃紧。而且将文件存储在 <code>Nginx</code> Web服务器内某目录下，深度的将 <code>Nginx</code>、网站、部署过程等强耦合在一起，无法使用 <code>CDN</code> 技术。</p><blockquote><p>CDN 是一种内容分发网络，部署在应用层，利用智能分配技术，根据用户访问的地点，按照就近访问的原则分配到多个节点，来实现多点负载均衡。<br>简单来说，用户就近访问，访问速度更快，大公司也无需搞一台超级带宽的存储服务器，只需使用多台正常带宽的 CDN 节点即可。<br>而 CDN 的常见实现是有一台源站服务器，多个 CDN 节点定时从源站同步。</p></blockquote><p>那如何将 <code>CDN</code> 与 <code>Nginx</code> 等 Web 服务器结合呢？<br>答案是将静态资源部署到 <code>CDN</code> 上，再将 <code>Nginx</code> 上的流量转发到 <code>CDN</code> 上，这种技术我们称之为『<strong>反向代理</strong>』。</p><p>此时，用户访问时流量走向 &amp; 研发构建部署过程大致如下：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/97e4477aff4a426896dcfee9a9492a41_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><p>此时，我们总体部署方案需要进一步做三步改造。</p><ul><li>构建时依据环境变量，将 <code>HTML</code> 中的静态资源地址加上 <code>CDN</code> 域名。</li><li>构建完成后将静态资源上传到 <code>CDN</code> 。</li><li>配置 <code>Nginx</code> 的反向代理，将静态资源流量转发到 <code>CDN</code>。</li></ul><p>其中，第 1、2 条涉及构建过程调整，以 <code>Webpack</code> 为例，我们需要做以下配置改造：</p><blockquote><p>a.  配置 <code>output</code> 为 <code>content-hash</code> &amp; <code>publicPath</code><br>b.  配置 <code>Webpack-HTML-Plugin</code></p></blockquote><p>下面是一个配置示例：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/57f6d3ee8bc64ab38c875ee37e140b9b_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> CDN_HOST = process.env.CDN_HOST;<span class="comment">// CDN 域名</span></span><br><span class="line"><span class="keyword">const</span> CDN_PATH = process.env.CDN_PATH; <span class="comment">// CDN 路径</span></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.ENV; <span class="comment">// 当前的环境等等</span></span><br><span class="line"><span class="keyword">const</span> VERSION = process.env.VERSION; <span class="comment">// 当前发布的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPublicPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Some code here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;CDN_HOST&#125;</span>/<span class="subst">$&#123;CDN_PATH&#125;</span>/<span class="subst">$&#123;ENV&#125;</span>/`</span>;<span class="comment">// 依据 ENV 等动态构造 publicPath</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publicPath = process.env.NODE_ENV === <span class="string">'production'</span> ? getPublicPath() : <span class="string">'.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.[name][contenthash:8].js'</span>,</span><br><span class="line">    publicPath,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注1：我们往往会将一套代码部署到多套前端环境，还需要在构建时注入当前部署相关环境变量（如 <code>staging</code>、<code>prod</code>、<code>dev</code>、<code>pre</code>等），以便动态构建 <code>publicPath</code>。<br>备注 2：这里动态构造的 <code>publicPath</code> 里，严格的将产物按环境 + 发布版本做了隔离 &amp; 收敛。<br>某业务前端曾将所有环境的静态资源放到一起，以Hash做区分。但疑似出现了文件名 + hash 冲突，但文件内容不一样，导致了线上事故。故墙裂建议严格对产物做物理隔离。<br>备注 3：<code>publicPath</code> 详解 <a href="https://webpack.docschina.org/configuration/output/#outputpublicpath" target="_blank" rel="noopener">webapck outputpublicpath</a><br>备注 4：此处使用了 <code>content-hash</code>，与 <code>hash</code>、<code>chunkhash</code>的区别请见：详解 <code>webpack</code> 中的 <code>hash</code>、<code>chunkhash</code>、<code>contenthash</code> 区别<br>备注 5：使用 <code>contenthash</code> 时，往往会增加一个小模块后，整体文件的 <code>hash</code> 都发生变化，原因为 <code>Webpack</code> 的 <code>module.id</code> 默认基于解析顺序自增，从而引发缓存失效。具体可通过设置 <code>optimization.moduleIds</code> 设置为 <code>&#39;deterministic&#39;</code> 。<br>具体详见 <a href="https://webpack.docschina.org/guides/caching/" target="_blank" rel="noopener">webpack 官方文档-缓存</a></p></blockquote><h4 id="构建完成后静态资源上传-CDN-源站"><a href="#构建完成后静态资源上传-CDN-源站" class="headerlink" title="构建完成后静态资源上传 CDN 源站"></a>构建完成后静态资源上传 CDN 源站</h4><p>上传 <code>CDN</code> 源站往往通过 <code>CLI</code> 调用各种客户端工具上传，此时要注意的是上传 <code>CDN</code> 依赖配置鉴权信息（如 文件存储的 Bucket Name/accessKey、ftp的账号密码）。这些鉴权信息不能直接写代码里，否则可能会有事故风险（想想为什么）！</p><p>最后一步改造是 <code>Nginx</code> 层反向代理改造</p><blockquote><p>反向代理（reverse proxy）：是指以代理服务器来接受网络请求，并将请求转发给内部的服务器，并且将内部服务器的返回，就像是二房东一样。<br>一句话解释反向代理 &amp; 正向代理：反向代理隐藏了真正的服务器，正向代理隐藏了真正的客户端。</p></blockquote><p><code>Nginx</code> 可通过设置 <code>proxy_pass</code> 配置代理转发，如</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~/static/</span> &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> <span class="variable">$cdn</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体详见 <a href="https://www.jianshu.com/p/b010c9302cd0" target="_blank" rel="noopener">nginx 之 proxy_pass详解</a></p><h3 id="静态资源组织总结"><a href="#静态资源组织总结" class="headerlink" title="静态资源组织总结"></a>静态资源组织总结</h3><p>最后，回顾一下</p><ul><li>为了最大程度利用缓存，将页面入口(<code>HTML</code>)设置为协商缓存，将 <code>JavaScript</code>、<code>CSS</code> 等静态资源设置为永久强缓存。</li><li>为了解决强缓存更新问题，将文件摘要（<code>hash</code>）作为资源路径(<code>URL</code>)构成的一部分。</li><li>为了解决覆盖式发布引发的问题，采用 <code>name-hash</code> 而非 <code>query-hash</code> 的组织方式，具体需要配置 <code>Wbpack</code> 的 <code>output.filename</code> 为 <code>contenthash</code> 。</li><li>为了解决 <code>Nginx</code> 目录存储过大 + 结合 <code>CDN</code> 提升访问速度，采用了 <code>Nginx</code> 反向代理 + 将静态资源上传到 <code>CDN</code>。</li><li>为了上传 <code>CDN</code>，我们需要按环境动态构造 <code>publicPath</code> + 按环境构造 <code>CDN</code> 上传目录并上传。</li><li>为了动态构造 <code>publicPath</code> 并且随构建过程插入到 <code>HTML</code> 中，采用 <code>Webpack-HTML-Plugin</code> 等插件，将编译好的带 <code>hash</code> + <code>publicPath</code> 的静态资源插入到 <code>HTML</code> 中。</li><li>为了保证上传 <code>CDN</code> 的安全，我们需要一种机制管控上传 <code>CDN</code> 秘钥，而非简单的将秘钥写到代码 / <code>Dockerfile</code> 等明文文件中。</li></ul><blockquote><p>简直是层层套娃！</p></blockquote><p>此时，我们已经基本获得了一套相对完备的前端静态资源组织方案。</p><blockquote><p>此时你可能已经发现了，前端静态资源部署后，还有被 <code>Nginx</code> 加工消费过程，才能被用户访问到。</p></blockquote><h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><p>现在我们已经探索出一套静态资源组织的解决方案。现在探讨一下构建的过程。我们每次构建时大约需要进行这些步骤：</p><ul><li>拉取远程仓库</li><li>切换到 XX 分支</li><li>代码安全检查（非必选）、单元测试等等</li><li>安装 <code>npm</code>/<code>yarn</code> 依赖<ul><li>设置 <code>node</code> 版本</li><li>设置 <code>npm</code>/<code>yarn</code> 源</li><li>安装依赖等</li></ul></li><li>执行编译 &amp; 构建</li><li>产物检查（比如检测打包后 <code>JS</code> 文件 / 图片大小、产物是否安全等，保证产物质量，非必选）</li><li>人工卡点（非必选，如必须 <code>Leader</code> 审批通过才能继续）</li><li>打包上传 <code>CDN</code></li><li>自动化测试（非必选，<code>e2e</code>）</li><li>配套剩余其他步骤</li><li>通知构建完成</li></ul><p>这其中，迎面而来的问题有：</p><ul><li>在什么环境执行构建？</li><li>如何保证每次构建部署环境相同？</li><li>由谁触发构建？</li><li>如何管理前面所述上传 <code>CDN</code> 等密钥（不增加成本、保证安全、保证构建上传可靠性）？</li><li>如何自动化触发构建 &amp; 自动化执行上述步骤？</li></ul><blockquote><p>假如每次都由人工执行，估计发版日就守着编译打包了，而且较为容易引发问题，比如某步骤遗漏或顺序错了。</p></blockquote><ul><li>如何提升构建速率？</li><li>构建完成如何通知研发同学构建完成了？</li></ul><blockquote><p>灵魂拷问有没有！</p></blockquote><p>为了解决上面问题，业界有一些解决方案：</p><ul><li>保证环境一致性：<a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker</a></li><li>按流程构建：<a href="https://cloud.tencent.com/developer/article/1504850" target="_blank" rel="noopener">Jenkins</a></li><li>自动化构建触发：<a href="https://segmentfault.com/a/1190000015437514" target="_blank" rel="noopener">Gitlab webhook</a> 通知</li><li>开始构建通知：依赖账号体系打通+ Gitlab Webhook</li><li>构建完成通知：依赖账号体系打通</li></ul><p>业界的大致实现，一般都为 Jenkins + Docker + GitlabWebHook，比如下面是一些实践：</p><p><a href="https://blog.csdn.net/weixin_49592546/article/details/109352249" target="_blank" rel="noopener">前端项目自动化部署——超详细教程（Jenkins、Github Actions）</a><br><a href="https://github.com/wdfe/ideploy" target="_blank" rel="noopener">iDeploy-为前端团队构建部署工程化而开发的一个持续交付平台</a></p><p>此时还有一些其他问题：</p><p>比如宇宙最重物质 <code>node_modules</code> 安装速度过慢的问题？<br>如何提升 <code>Build</code> 构建速</p><p>上述往往在各大公司都有相对完善的构建系统 &amp; 解决方案等，各公司各不相同但大致类似，故本文跳过该步骤。</p><h3 id="前端发布服务-预发环境、版本管理（秒级回滚）、小流量、灰度、AB测试"><a href="#前端发布服务-预发环境、版本管理（秒级回滚）、小流量、灰度、AB测试" class="headerlink" title="前端发布服务 - 预发环境、版本管理（秒级回滚）、小流量、灰度、AB测试"></a>前端发布服务 - 预发环境、版本管理（秒级回滚）、小流量、灰度、AB测试</h3><p>假定我们静态资源组织完成，也搞定了自动化构建部署，也配好了 <code>Nginx</code> 的反向代理，我们的网站终于第一次上线了。</p><p>但第二次第三次上线怎么办？直接发到生产环境做回归测试的风险极大，但又不能本地部署前端测试环境去连接后端生产库（可以想想为什么），所以我们需要一个预发（<code>Pre</code>）环境，除了非测试人员访问不到之外，其他所有环节都和生产环境保持一致！</p><p>此时遇到第一个需求，预发环境功能。</p><p>假如我们某个功能是元旦零点发布，跨年时守在服务器面前点发布？万一 npm 抽风拉取依赖失败导致构建失败，或者上线后发现有bug，那就只能凉凉。</p><p>或者，随着时间推移大家前端项目越积越大，<code>node_modules</code> 质量逐渐超越银河系总质量，构建的时间往往会超过二十分钟甚至更久。某天某次我们新上线了功能后，却发现有致命阻塞性 bug，收款后自动退款 1.5 倍！想立即回滚版本？那就且等着，大眼瞪小眼的等它慢慢编译吧。这个时候才真的是时间就是金钱，再编译慢点公司就破产啦。</p><p>此时有没有一种办法，能在发现问题后，立即将版本回滚呢？并且这个回滚操作，回滚的同学也不应该登陆服务器去做操作（想想为什么？）。</p><p>此时遇到第二个需求，版本管理功能。 即可提前将静态资源上线，也需要保留每个历史版本，并且能实现瞬间切换版本，且切换过程不应该登陆服务器操作（想想为什么）。</p><p>其次是，假定 <code>PM</code> 对功能不断优化，想先灰度一部分用户，或者想做一些 <code>AB</code> 测试，比如给广东用户推广福建美食，给重庆用户推广钵钵鸡。</p><p>此时我们有两种方案，方案一是将把钵钵鸡和福建美食都打包到一份代码产物里，再在运行时根据地域做切换。但很快你的代码产物里就有钵钵鸡冷锅串串热锅串串老妈兔头跷脚牛肉狼牙土豆以及福建美食等等，会串味儿的对不对？况且热锅串串和冷锅串串打包混到一起我就第一个不同意，简直是对美食的亵渎！所以方案一不可取。</p><blockquote><p>实际上，现实中往往会热锅串串冷锅串串这样完全不兼容的两份改动同时在线上运行做 AB 测试。</p></blockquote><p>方案二是我们将热锅串串和冷锅串串分开打包，让热锅不犯冷锅。再设计一些机制，比如携带了香蕉糖果（<code>cookie</code>）的同学给跷脚牛肉锅，讲港东话的同学福建美食锅，四川地域的同学随机给火锅干锅汤锅鱼火锅。岂不乐哉？</p><p>大家应该很容易发现，这种机制是极其多变的，大概率朝令夕改。难道我们每次想调整干锅、鱼火锅的比例，就要登陆服务器做调整？某天干锅卖完了但又没带电脑回家怎么办？</p><p>此时遇到第三个需求，随时调整的<strong>小流量测试</strong>、<strong>AB-Test测试</strong>、<strong>灰度上线</strong>等等功能。</p><p>总结一下，为了满足复杂的线上需求，在部署层面总体来说需要：<strong>预发环境</strong>、<strong>版本管理</strong>、<strong>小流量</strong>、<strong>灰度</strong>、<strong>AB测试</strong>等功能。</p><h4 id="静态资源的加工"><a href="#静态资源的加工" class="headerlink" title="静态资源的加工"></a>静态资源的加工</h4><p>如前所述，前端静态资源部署到 <code>CDN</code> 后，有一道 <code>Nginx</code> 反向代理做转发的加工工序。事实上，为了解决各种部署问题或为了提升性能，人们往往而需要对静态资源做更多的加工工序。</p><p>比如，部分 <code>Web</code> 应用为了提升首屏性能，一种常见的方式为通过 <code>BFF</code> 层或通过后端直出 <code>HTML</code>，并且在过程中注入若干信息，如 <code>userInfo</code>、用户权限信息、灰度信息等等，从而大幅降低前端登陆研发成本 &amp; 降低首屏耗时。</p><p>下面是后端直出 <code>HTML</code> 的一种简要流程。</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/b1a8e5e937754a7b93c2545dc9822f58_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><p>主要流程为前端构建出的 <code>HTML</code> 包含若干模板变量，后端收到请求后，通过各种 <code>Proxy</code> 层将 <code>Cookie</code> 转换成用户信息，再按依据版本配置从 <code>CDN</code> 加载 <code>index.html</code>, 并使用模板引擎等方式将模板变量替换为用户信息，最终吐回给浏览器的则是已经包含用户信息的 <code>HTML</code> 了！</p><h4 id="Pre-环境、灰度上线的常见实现"><a href="#Pre-环境、灰度上线的常见实现" class="headerlink" title="Pre 环境、灰度上线的常见实现"></a>Pre 环境、灰度上线的常见实现</h4><p>如前所述，我们的静态资源为非覆盖式发布，多次部署后，线上存在若干版本静态资源。实现<code>Pre</code>环境/灰度上线的思路则是：通过一定的机制，让特定用户访问特定静态资源版本，从而达到访问<code>Pre</code>/灰度上线的能力。</p><h5 id="方案一-Nginx-层动态转发"><a href="#方案一-Nginx-层动态转发" class="headerlink" title="方案一 Nginx 层动态转发"></a>方案一 Nginx 层动态转发</h5><p>一种常见的 <code>Pre</code> 机制是静态资源部署多个版本后，开发者的通过 ModHeader 等浏览器插件，在请求中携带特定 <code>Header</code>（如xx-env=pre），在 <code>Nginx</code> 层消费该 <code>Header</code> 并动态转发到对应环境的静态资源上，实现访问 <code>Pre</code> 环境目的。此时，除静态资源为特定版本外，所有环境都是生产环境，可以将变量范围控制在最小。</p><p>流程大致如图：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/d68c978a352b442398b9f93a7c5ea9bd_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><blockquote><p>Nginx 可通过配置 rewrite 设置转发，如下所示。</p></blockquote><blockquote><p>详情请查阅：nginx配置<a href="https://leokongwq.github.io/2016/11/23/nginx-rewrite.html" target="_blank" rel="noopener">rewrite指令详解</a></p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /example &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^</span> <span class="variable">$cdn</span>/<span class="variable">$http_x_xx_env</span>/index.html <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> <span class="variable">$cdn</span>/prod/index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># $http_x_xx_env 表示取自定义的 Request Header 字段 xx_env</span></span><br></pre></td></tr></table></figure><p>该方案优点为配置简单高效，适用于工程师。</p><p>缺点为每个用户都需要手动配置，不适用于移动端，且无法让特定用户被动精确访问某版本，比如 PM、KP 用户来配置 Header 成本过高。</p><p>同理，也可以在 Nginx 层按一些其他规则处理，实现灰度上线的能力。<br>如通过一定随机数 rewrite，达到小范围随机灰度。<br>获取 ua 并 rewrite，达到按浏览器定向灰度。<br>通过 Nginx GeoIP 获取地域信息，达到按地域灰度。</p><p>但上述灰度方案配置复杂，而灰度比例 / 范围往往会配置较多，每次上线都需要运维登陆生产服务器修改，较容易出各种事故。故不推荐使用，仅供拓宽思路。</p><h5 id="方案二-动态配置-服务端转发"><a href="#方案二-动态配置-服务端转发" class="headerlink" title="方案二 动态配置 + 服务端转发"></a>方案二 动态配置 + 服务端转发</h5><p>但 Pre 环境或灰度往往需要精确定位某些特定人群，如给特定PM、HR、远端报错的特定用户、KP用户 甚至给某个部门开 Pre环境等。上述同学工程背景相对缺失 / 较忙 / 通过移动端访问，此时通过修改 Header 的方式不再适用。故我们仍然要寻找某种机制，达到能方便随时调整 Pre/ 灰度范围又不用重新发版上线。既然需要按用户维度来定向，此时就依赖后端帮忙处理了。</p><p>而为了能随时随地调整灰度 / Pre 策略，而非依赖调整代码发版上线，此时引入配置中心的概念。</p><blockquote><p>配置中心：一般是独立的平台 / SDK，提供动态配置管理的解决方案，提供功能有配置管理、版本管理、权限管理、灰度发布等等。后端应用通过接口消费，故配置中心和后端解耦，可以随时修改调整配置而非重新发版。<br>配置中心一般是配置一个 JSON 对象。<br>配置中心JSON对象人工维护容易引发问题，故增加机器人来降低出错几率。</p></blockquote><p>下图是依赖配置中心 + 服务端转发的流程图：</p><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/1b36fe5f6468468e968a78db6fad315e_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.webp" alt="image"></p><p>主要流程为：</p><ul><li>前端攻城狮同学部署多个版本静态资源到 CDN 上（问题？如何管控多版本静态资源？）。</li><li>后端收到请求后，通过各种 Proxy 层将 Cookie 转换成用户信息。</li><li>后端读取配置中心数据，依据用户信息判断给用户访问什么环境，加载具体环境 index.html</li><li>后端返回给浏览器加工后的 index.html</li><li>若需添加具体 KP 等同学到 Pre 名单，攻城狮同学只需调用机器人/Bot 等，修改配置中心，即可生效。</li></ul><blockquote><p>注意，在上述架构下，若线上某用户发生某些难以排查的问题，也可发布特定的版本，在配置中心修改后让用户访问特定版本页面，从而简化排查问题的过程。</p></blockquote><p>此时，一些小流量配置，AB实验，版本管理其实也可以通过该方案实施。<br>该方案优点：可以随时调整，不用后端发版，移动端也可生效。<br>该方案缺点：</p><ul><li>和服务端强绑定（要求用户信息，在所难免）。</li><li>每次都需要从 <code>CDN</code> 加载 <code>HTML，</code> 有一定性能浪费。但若缓存 <code>HTML</code>，发版环节还要通知服务端，总体增加复杂度。</li><li>若考虑 <code>CDN</code> 故障，服务端做 <code>CDN</code> 降级会增加复杂度。<br>版本管理 / 小流量等为通用需求，而该方案每个后端应用都需要开发或接入。</li><li>常见的配置中心又一般为 <code>JSON</code> 配置，比较简陋，和发版的多环境无法关联，依赖人为配置，有出错的风险（如发版 <code>v1.2501</code>，配置中心手动配置时手误改成了<code>v1.2051</code>）。</li></ul><h4 id="前端发布服务实现与设计"><a href="#前端发布服务实现与设计" class="headerlink" title="前端发布服务实现与设计"></a>前端发布服务实现与设计</h4><p>可能部分同学对线上产物实行版本管理会误理解对代码增加版本管理（如发版后手动 / 自动打<code>Tag</code>），后续需要时再次发版部署即可满足需求。但如前所述，通过源码做版本管理灵活性较差，无法做到一键 &amp; 秒级切换版本，不满足商业化环境多变 &amp; 复杂的需要。</p><p>那么如何进行版本管理呢？答案是对<strong>构建产物进行深层次加工 &amp; 管理</strong>。</p><p>与此同时，版本管理/小流量是前端部署的常见公共业务需求，应该和业务后端服务脱离，故这里提出一个新的公共服务，纯用于前端部署相关，此处将之称为 <code>Page Server</code>，用于具体的 <code>index.html</code> 文件管理 &amp; 承接 <code>Nginx</code> 流量或业务后端流量等。</p><p>同时，鉴于版本管理、小流量策略等调整会特别频繁，每次调整不应该都登录服务器，故我们需要一个新的服务 &amp; 界面，用于操作管理版本、调整小流量等信息，并且与上述 <code>Page Server</code> 同步，此处我们将该服务称之为 <code>Page Config Web</code>。</p><p>而我们的 <code>Page Server</code>则可能会有很多个实例，部署在多个集群上，以满足跨国部署、多部门项目部署等要求。所以理想情况下 <code>Page Config Web</code> 还要承接 <code>PageServer</code> 的创建、管理、配置等工作。所以 <code>PageConfigWeb</code> 与 <code>PageServer</code> 是 1 比 N 关系（或M比N，用于跨国部署等）。</p><p>同时，我们一个前端项目可能有多套前端环境，<code>PageSever</code> 在固定集群算公共设施，这些环境理论上都可以由一个或多个 <code>PageServer</code> 承载。故一个 <code>PageServer</code> 和多个前端环境是 1 比 1 或者 1 比 N 关系。</p><p>此时，对于 <code>Nginx</code> 来的流量，我们需要一种机制来区分该流量属于哪个环境实例，比如通过 <code>URL</code> 来区分，我们可以称之为<strong>路由</strong>。</p><p>最后，为了保证上述服务的正确性和自动化，构建部署（新增版本）完成后，要同步到上述两个服务，以确保版本管理的正确性。</p><p>最后，大致的流程图如下：</p><blockquote><p>超大图预警</p></blockquote><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/f166c3371c854c878d2bce8c1450500e_tplv-k3u1fbpfcp-zoom-in-crop-mark_1304_0_0_0.awebp" alt="image"></p><p>本质上来说，相当于有一个公用的中间服务，部署在多个集群上，与构建发布过程深度绑定，用于承接 <code>HTML</code> 的流量，并通过 <code>Web</code> 站点设置<strong>小流量规则</strong>、<strong>版本</strong>等等，来满足多变的上线需求。<br>其中，<code>PageServer</code> 在承载 <code>HTML</code> 服务时，可做一些其他工作，比如：</p><ul><li><code>SSR</code></li><li><code>CDN</code> 降级，用于 <code>CDN</code> 异常时直出 <code>HTML</code> 中将静态资源替换为可用的 <code>CDN</code> 站点。</li><li>404 处理</li><li>兜底页（比如服务出现故障，短时间内无法修复时出兜底）</li><li>模板渲染（如做模板替换，将 <code>query</code> 替换到模板中等）</li><li>特殊时期全局处理，如注入全局样式将页面全局置灰</li></ul><p>等等。</p><blockquote><p><code>PageConfig Web</code> 和 <code>PageServer</code> 中有构建后的所有版本信息，理论上可以缓存每个版本的 <code>HTML</code> <code>文件，并且为了优化性能，PageServer</code> 中可将最新全量版本的 <code>HTML</code> 文件缓存到内存中，最大程度提升响应速度，其余版本存储到 <code>Redis</code> 等缓存中。</p></blockquote><p>下面以发布一个正式版本 <code>v.1.0.2502</code> 并且回滚过程为例：</p><ul><li>代码合并，触发自动化构建，构建产物以环境（<code>env</code>）+版本（<code>env</code>） + 版本（<code>env</code>）+版本（<code>version</code>） + <code>name-hash</code> 方式组织，并上传到 <code>CDN</code>。</li><li>构建完成后，构建脚本通知攻城狮同学、同步 <code>PageServer</code>、<code>PageConfig Web</code> 服务有新版本 <code>v.1.0.2502</code> 。</li><li>攻城狮同学收到通知后，到 <code>PageConfig Web</code> 站点发布新版本<code>v.1.0.2502 （PRE）</code>，并为该版本配置 <code>PRE</code> 环境小流量规则<code>xx-env = pre</code>。此时，只有设置特定 <code>Header</code> 才能访问该版本。<ul><li>若是 <code>Nginx</code> 直接转发，则攻城狮通过设置 <code>Header</code> 访问 <code>PRE</code> 版本。</li><li>若是通过服务端转发，攻城狮通过配置中心设置 <code>PRE</code> 白名单，即可让用户访问 <code>PRE</code> 版本。</li></ul></li><li>在 <code>PRE</code> 版本验收完成后，攻城狮登录 <code>PageConfig Web</code> 站点，发布正式版本 <code>v.1.0.2502</code> （不带小流量信息）。此时立即生效。</li><li>生效后线上回归，发现有 <code>bug</code>，攻城狮立马登录 <code>PageConfig Web</code> 站点，将版本回滚为上一版本 <code>v.1.0.2501</code>。此时立即生效。</li></ul><h3 id="关于部署的总结"><a href="#关于部署的总结" class="headerlink" title="关于部署的总结"></a>关于部署的总结</h3><h4 id="静态资源组织部分"><a href="#静态资源组织部分" class="headerlink" title="静态资源组织部分"></a>静态资源组织部分</h4><ul><li>为了最大程度利用缓存，将页面(HTML)设置为协商缓存，将 JavaScript、CSS 等设置为永久强缓存。</li><li>为了解决强缓存更新问题，将文件摘要（hash）作为资源路径(URL)构成的一部分。</li><li>为了解决覆盖式发布引发的问题，采用 name-hash 而非 query-hash 的组织方式，具体需要配置 webpack 的 output.filename 为 contenthash 方式。</li><li>为了解决 Nginx 目录存储过大 + 结合 CDN 提升访问速度，采用了 Nginx 反向代理+ 将静态资源上传到 CDN。</li><li>为了上传 CDN，我们需要按环境动态构造 publicPath + 按环境构造 CDN 上传目录并上传。</li><li>为了动态构造 publicPath 并且随构建过程插入到 HTML 中，采用 Webpack-HTML-Plugin 等插件，将编译好的带 hash + publicPath 的静态资源插入到 HTML 中。</li><li>为了保证上传 CDN 的安全，我们需要一种机制管控上传 CDN 秘钥，而非简单的将秘钥写到代码 / Dockerfile 等明文文件中。</li></ul><h4 id="自动化部署部分"><a href="#自动化部署部分" class="headerlink" title="自动化部署部分"></a>自动化部署部分</h4><p>为了提升部署效率，100% 避免因部署出错，需要设计 &amp; 搭建自动化部署平台，以 Docker 等保证环境的一致性，以 Jenkins 等保证构建流程的串联。使用es-build等提升构建效率。</p><h4 id="前端部署-amp-静态资源加工"><a href="#前端部署-amp-静态资源加工" class="headerlink" title="前端部署 &amp; 静态资源加工"></a>前端部署 &amp; 静态资源加工</h4><p>关于前端部署，能总结出下面几个原则/要求：</p><ul><li>构建发布后，不应该被覆盖。</li><li>构建发布后，静态资源应当永久保存在服务器/CDN 上，即只可读。</li><li>静态资源组织上，每个版本应该按文件夹存储，做到资源收敛。这样假如真要删除时，可按版本删除。（如某个版本代码泄密）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> CDN_HOST = process.env.CDN_HOST;<span class="comment">// CDN 域名</span></span><br><span class="line"><span class="keyword">const</span> CDN_PATH = process.env.CDN_PATH<span class="string">''</span>; <span class="comment">// CDN 路径</span></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.ENV; <span class="comment">// 当前的环境等等</span></span><br><span class="line"><span class="keyword">const</span> VERSION = process.env.VERSION; <span class="comment">// 当前发布的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPublicPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Some code here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;CDN_HOST&#125;</span>/<span class="subst">$&#123;CDN_PATH&#125;</span>/<span class="subst">$&#123;ENV&#125;</span>/<span class="subst">$&#123;VERSION&#125;</span>/`</span>;<span class="comment">// 依据 ENV 等动态构造 publicPath</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.[name][contenthash].js'</span>,</span><br><span class="line">    publicPath: getPublicPath(),</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>故 publicPath 应增加 version 字段</p></blockquote><ul><li>发布过程应该自动化，开发人员不应该直接接触服务器。</li><li>版本切换时，也应当不接触服务器。</li><li>版本切换能秒级生效。（如 v0.2 切换 v0.3，立即生效）。</li><li>线上需要能同时生效多个版本，满足 AB 测试、灰度、PRE 环境等小流量需求。</li></ul><p>上述需求都相对复杂多变，为了应对复杂的线上需求，可以对静态资源做深度加工，如通过服务端直出 HTML、通过配置中心实现按用户 PRE 等等。</p><h4 id="前端发布服务"><a href="#前端发布服务" class="headerlink" title="前端发布服务"></a>前端发布服务</h4><p>面对复杂的商业化需求，方便多前端业务实现版本管理、灰度、PRE、AB 测试等小流量功能，我们设计了一个中间服务 PageConfig Web &amp; PageServer，与 Nginx 和各种后端相结合，达到配置即时生效的能力。</p><h3 id="灵魂拷问的部分答案"><a href="#灵魂拷问的部分答案" class="headerlink" title="灵魂拷问的部分答案"></a>灵魂拷问的部分答案</h3><p>Q: 前端代码从 tsx/jsx 到部署上线被用户访问，中间大致会经历哪些过程？<br>A: 经历本地开发、远程构建打包部署、安全检查、上传CDN、Nginx做流量转发、对静态资源做若干加工处理等过程。<br>Q：可能大部分同学都知道强缓存/协商缓存，那前端各种产物（HTML、JS、CSS、IMAGES 等）应该用什么缓存策略？以及为什么？</p><ul><li>若使用协商缓存，但静态资源却不频繁更新，如何避免协商过程的请求浪费？</li><li>若使用强缓存，那静态资源如何更新？</li></ul><p>A：HTML使用协商缓存，静态资源使用强缓存，使用name-hash（非覆盖式发布）解决静态资源更新问题。<br>Q：配套的，前端静态资源应该如何组织？<br>A：搭配 Webpack 的Webpack_HTML-Plugin &amp; 配置 output publicPath等。<br>Q：配套的，自动化构建 &amp; 部署过程如何与 CDN 结合？<br>A：自动化构建打包后，将产物传输到对应环境 URL 的CDN上。<br>Q：如何避免前端上线，影响未刷新页面的用户？<br>A：使用name-hash方式组织静态资源，先上线静态资源，再上线HTML。<br>Q：刚上线的版本发现有阻塞性 bug，如何做到秒级回滚，而非再次部署等 20 分钟甚至更久？<br>A：HTML文件使用非覆盖方式存储在CDN上，搭建前端发布服务，对 HTML 按版本等做缓存加工处理。当需要回滚时，更改发布服务HTMl指向即可。<br>Q: CDN 域名突然挂了，如何实现秒级 CDN 降级修补而非再次全部业务重新部署一次？<br>A1: 将静态资源传输到多个 CDN 上，并开发一个加载Script的SDK集成到HTML中。当发现CDN资源加载失败时，逐步降级CDN域名。<br>A2：在前端发布服务中，增加HTML文本处理环节，如增加CDN域名替换，发生异常时，在发布服务中一键设置即可。<br>Q：如何实现一个预发环境，除了前端资源外都是线上环境，将变量控制前端环境内？<br>A：对静态资源做加工，对HTML入口做小流量。<br>Q：部署环节如何方便配套做 AB 测试等？<br>A：参见前端发布服务<br>Q：如何实现一套前端代码，发布成多套环境产物？<br>A：使用环境变量，将当前环境、CDN、CDN_HOST、Version等注入环境变量中，构建时消费 &amp; 将产物上传不同的CDN即可。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="//jdeseva.github.io/2022/06/13/2021年当我们聊前端部署时，我们在聊什么/WX20220613-125300%402x.png" alt="images"></p>]]></content>
      
      
      
        <tags>
            
            <tag> frame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2022/01/05/nginx/"/>
      <url>/2022/01/05/nginx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文档只阐述简单的 <code>nginx</code> 配置 尽量以解决问题为主，不涉及原理性内容</p></blockquote><p><code>nginx</code> 是常用的服务器，其功能包括但不限于以下内容</p><ul><li>负载均衡</li><li>代理（包括正向反向）</li><li><code>TCP</code> 转发</li><li>控制 <code>http</code> 缓存</li></ul><p><code>TCP</code> 转发不在本文的讲解之列，如确实想知道，请咨询后端。</p><a id="more"></a><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><code>nginx</code> 最重要的功能就是代理。关于代理，具体可以查看<a href="https://zhuanlan.zhihu.com/p/82300486" target="_blank" rel="noopener">这篇文档</a>。</p><p>代理分为<strong>正向代理</strong>和<strong>反向代理</strong>，两者的区分可以参考上述贴文。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><code>nginx</code> 最常用的功能，也是绝大多数的形式，就是反向代理。常见配置如下</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="comment"># 默认API</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.a.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代表的意义如下</p><ul><li>匹配 <code>/api</code> 开头的请求路径（注意是所有）</li><li>以 <code>/api</code> 为断点，将前部全部覆写为 <code>proxy_pass</code> 的内容</li></ul><p><strong>注意（非常重要）</strong></p><p>关于 <code>proxy_pass</code> 路径后面带不带 <code>/</code> 的问题</p><ul><li>带 <code>/</code>，代表删除匹配模式串，即以 <code>/api</code> 为断点，将前部（<strong>包括</strong> <code>/api</code>）全部覆写为 <code>proxy_pass</code> 的内容</li><li>不带 <code>/</code> ，即以 <code>/api</code> 为断点，将前部（<strong>不包括</strong> <code>/api</code>）全部覆写为 <code>proxy_pass</code> 的内容。</li></ul><p>举例如下</p><blockquote><p>请求地址：<a href="https://test.com/api/commonUpload" target="_blank" rel="noopener">https://test.com/api/commonUpload</a></p></blockquote><ul><li>带 <code>/</code></li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="comment"># 默认API</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.a.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>等效于 <a href="http://www.a.com/commonUpload" target="_blank" rel="noopener">http://www.a.com/commonUpload</a></p></blockquote><ul><li>不带 <code>/</code></li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="comment"># 默认API</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://www.a.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>等效于 <a href="http://www.a.com/api/commonUpload" target="_blank" rel="noopener">http://www.a.com/api/commonUpload</a></p></blockquote><p><alert type="info">下面会结合前端本地代码和服务端 <code>nginx</code> 配置具体说明</alert></p><blockquote><p>对应后台真实接口地址为 <a href="https://baidu.com/api/auth/login?xxxx" target="_blank" rel="noopener">https://baidu.com/api/auth/login?xxxx</a></p></blockquote><ul><li>前端代码如下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api 请求地址</span></span><br><span class="line">axios.get(<span class="string">'ding/auth/login'</span>, &#123; <span class="attr">params</span>: data, ...opt &#125;) <span class="comment">// 注意需要设置 axios 默认请求前缀为 /api</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地反向代理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> API_SERVER = <span class="string">'https://baidu.com/api'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: process.env.API_SERVER ?? API_SERVER, <span class="comment">// 测试环境</span></span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">    <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端浏览器显示为 （假设项目访问地址为 http://localhost:3000/）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:3000/api/auth/login?xxxx</span></span><br></pre></td></tr></table></figure><ul><li><code>nginx</code> 配置如下</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /api &#123;</span><br><span class="line">    <span class="comment"># 默认API</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> https://baidu.com/api;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为两个前缀一样，其实也可以如下配置 但是不建议</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy_pass https://baidu.com;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>一般正向代理指的是 <code>nginx</code> 作为一个静态资源服务器的场景，一般 <code>nginx</code> 的一个 <code>server</code> 就是正向代理</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 端口</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">4000</span>;</span><br><span class="line">    <span class="comment"># 匹配请求中的host值</span></span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /app;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$</span> &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(?:js|css)$</span> &#123;</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(?:htm|html)$</span> &#123;</span><br><span class="line">        <span class="attribute">add_header</span> Cache-Control</span><br><span class="line"></span><br><span class="line">            <span class="string">"private, no-store, no-cache, must-revalidate, proxy-revalidate"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /api &#123;</span><br><span class="line">        <span class="comment"># 默认API</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://API_SERVER/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Headers</span><br><span class="line"></span><br><span class="line">            <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span> ) &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /app;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述部分参数的含义如下</p><table><thead><tr><th>参数名</th><th>参数说明</th></tr></thead><tbody><tr><td>listen</td><td>监听端口，一般 <code>http</code> 监听80， <code>https</code>监听443</td></tr><tr><td>server_name</td><td>对外访问域名</td></tr><tr><td>root</td><td>正向代理资源根目录（绝对路径）</td></tr><tr><td>location</td><td><code>nginx</code> 代理规则</td></tr><tr><td>error_page</td><td><code>nginx</code> 错误页</td></tr></tbody></table><h2 id="控制缓存"><a href="#控制缓存" class="headerlink" title="控制缓存"></a>控制缓存</h2><p>众所周知，http 缓存分为强缓存，协商缓存。最经典的莫过于 <code>200（OK），from disk</code>以及<code>304</code>，那么 <code>nginx</code> 怎么控制缓存？</p><p>关于http缓存的内容此处按下不表，请自行查看百度。</p><p>关于 <code>nginx</code> 设置缓存，其实也是通过设置 <code>location</code> 代理规则来实现的，具体如下</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(?:js|css)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述内容代表 js、css资源7天有效</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(?:htm|html)$</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control</span><br><span class="line"></span><br><span class="line">        <span class="string">"private, no-store, no-cache, must-revalidate, proxy-revalidate"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述内容代表 html、htm文件禁止缓存。</p><p>通过上述可以看出， <code>nginx</code> 设置缓存是通过代理规则，利用正则对代理文件进行资源匹配，对匹配到的资源添加 <code>expires</code> 过期时间，或者直接设置 <code>Cache-Control</code> response头进行强缓存设置。</p><blockquote><p>未完待续</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> frame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentry</title>
      <link href="/2022/01/05/Sentry/"/>
      <url>/2022/01/05/Sentry/</url>
      
        <content type="html"><![CDATA[<p>Sentry 监控服务接入主要分为以下几个步骤，请务必阅读仔细。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>登录Sentry控制台，在对应组织下点击创建项目</p><p>选择对应语言，我们一般是 <code>Vue</code>。</p><a id="more"></a><p><img src="//jdeseva.github.io/2022/01/05/Sentry/QQ%E6%88%AA%E5%9B%BE20220105165141.png" alt="Sentry"></p><p>然后输入项目名称，注意项目名称是<strong>英文</strong>，约定：<strong>项目git名一致</strong></p><p>然后点击创建项目，之后会进入<code>SDK</code>接入提示界面，类似如下界面</p><p><img src="//jdeseva.github.io/2022/01/05/Sentry/QQ%E6%88%AA%E5%9B%BE20220105165408.png" alt="SDK"></p><h2 id="SDK-接入"><a href="#SDK-接入" class="headerlink" title="SDK 接入"></a>SDK 接入</h2><p>按照文档描述，使用 <code>npm</code> 安装 <code>SDK</code>，然后引入，注意区分项目版本（<code>Vue2</code>、<code>Vue3</code>），然后在项目入口文件下写入以下代码（大部分和文档描述一致，有小部分改动）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">"@sentry/vue"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Integrations &#125; <span class="keyword">from</span> <span class="string">"@sentry/tracing"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: <span class="string">'&lt;文档描述中的 dsn&gt;'</span>,</span><br><span class="line">  environment: process.env.VUE_APP_SENTRY_ENVIRONMENT,</span><br><span class="line">  integrations: [</span><br><span class="line">    <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [<span class="string">'localhost'</span>, /^\<span class="comment">//]</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">  <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">  tracesSampleRate: <span class="number">1.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意上述代码中的 <code>environment</code> 以及 <code>tracingOrigins</code></strong>。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>为了区分环境，我们需要在项目根目录下新建几个 <code>vue</code> 的环境变量文件（注意必须是<code>Vue</code>项目才有效）</p><ul><li>.env</li><li>.env.development</li><li>.env.production</li><li>.env.preview</li></ul><p>上述文件中，<code>.env.preview</code> 是非必选的，其他必选，文件内容如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV=development</span><br><span class="line">VUE_APP_SENTRY_ENVIRONMENT=development</span><br></pre></td></tr></table></figure><p>注意，文件中必须要有 <code>NODE_ENV</code> 以及 <code>VUE_APP_SENTRY_ENVIRONMENT</code> 这两项，并且 <code>NODE_ENV</code> 要在文件第一行，其中 <code>VUE_APP_SENTRY_ENVIRONMENT</code> 代表 <code>SDK</code> 运行环境，一般开发环境为 <code>develop</code>，部署环境为 <code>production</code>，可以继续细化测试，QA等环境，需要部署时注意。</p><p>上述操作完成后，<code>SDK</code> 即接入成功，无需额外操作即可正常使用项目。</p><p><strong>注意</strong></p><p>为了节省服务器资源，建议大家开发环境不要上传日志信息，可以调试测试是否可以上传，测试通过后通过判断，取消开发环境日志上传</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (env.NODE_ENV !== <span class="string">'development'</span>) &#123;</span><br><span class="line">    Sentry.init(&#123;</span><br><span class="line">      dsn: <span class="string">'项目的dsn'</span>,</span><br><span class="line">      environment: <span class="string">'环境变量'</span>,</span><br><span class="line">      release: <span class="string">'版本信息'</span>,</span><br><span class="line">      integrations: [</span><br><span class="line">        <span class="keyword">new</span> VueIntegration(&#123;</span><br><span class="line">          Vue,</span><br><span class="line">          tracing: <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">        <span class="comment">// routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span></span><br><span class="line">          tracingOrigins: [<span class="string">'localhost'</span>, /^\<span class="comment">//]</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">      <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">      <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">      tracesSampleRate: <span class="number">1.0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="查看监控"><a href="#查看监控" class="headerlink" title="查看监控"></a>查看监控</h2><p>进入控制台页面，点击项目，选择刚才创建的项目，可以查看概览，可以选择环境查看</p><p><img src="//jdeseva.github.io/2022/01/05/Sentry/QQ%E6%88%AA%E5%9B%BE20220105165451.png" alt="project"></p><p>点击左侧问题即可查看问题</p><p>点击问题即可查看详细问题，其他额外操作请自行探索。</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>Sentry 默认支持版本管理，对于版本管理，我们做以下约定，目前仅对 <code>monorepo</code> 项目做版本管理，为了对应版本管理，<code>SDK</code> 代码需要做以下改动</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">"@sentry/vue"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Integrations &#125; <span class="keyword">from</span> <span class="string">"@sentry/tracing"</span>;</span><br><span class="line"><span class="keyword">import</span> Pkg <span class="keyword">from</span> <span class="string">'../package.json'</span> <span class="comment">// 根据具体项目来，项目的 package.json</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: <span class="string">'&lt;文档描述中的 dsn&gt;'</span>,</span><br><span class="line">  environment: <span class="string">'&lt;环境信息&gt;'</span>,</span><br><span class="line">  release: <span class="string">`<span class="subst">$&#123;Pkg.name&#125;</span>@<span class="subst">$&#123;Pkg.version&#125;</span>`</span>,</span><br><span class="line">  integrations: [</span><br><span class="line">    <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [<span class="string">'localhost'</span>, /^\<span class="comment">//]</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">  <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">  tracesSampleRate: <span class="number">1.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意上述的 <code>release</code> 项，添加上述代码后，无其他改动，如需修改版本号，则由<strong>对应项目负责人</strong>使用 <code>lerna publish</code> 命令进行操作，需要在 <code>release</code> 分支进行操作。</p><h2 id="上传-sourcemap"><a href="#上传-sourcemap" class="headerlink" title="上传 sourcemap"></a>上传 sourcemap</h2><p>sourcemap 是打包生成的 <code>.map</code> 文件，是代码压缩后和源代码的一个映射文件，正常部署之后的代码都是压缩过的。 Sentry 只会收集浏览器端的错误，因此搜集过来的代码是压缩过的，如下图</p><p><img src="//jdeseva.github.io/2022/01/05/Sentry/QQ%E6%88%AA%E5%9B%BE20220105165559.png" alt="code"></p><p>但是如果我们上传了 sourcemap 文件，那么错误收集之后的样子就会如下</p><p><img src="//jdeseva.github.io/2022/01/05/Sentry/QQ%E6%88%AA%E5%9B%BE20220105165654.png" alt="error"></p><p>因此我们可以看出，sourcemap 文件可以极大的方便线上问题定位。上传 sourcemap 主要分为以下几个步骤</p><ul><li>打包</li><li>上传 sourcemap 文件到 Sentry 服务器</li><li>删除代码包中的 <code>.map</code> 文件（Why？）</li><li>部署代码到应用服务器</li></ul><p>为什么要上传 sourcemap 文件之后删除？是因为在正式环境暴露 sourcemap 文件就意味着把代码逻辑完全暴露给用户，极易遭受不法分子的安全攻击，或者代码机密泄漏，因此我们需要上传完成后删除 sourcemap 文件。</p><p>1、打包</p><p>打包之前需要安装部分插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @sentry/webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后在打包入口文件中写入如下配置（以 <code>VueCLI3</code> 举例）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SentryWebpackPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> Pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.plugins = [</span><br><span class="line">      ...config.plugins,</span><br><span class="line">       <span class="keyword">new</span> SentryWebpackPlugin(&#123;</span><br><span class="line">        release: <span class="string">`<span class="subst">$&#123;Pkg.name&#125;</span>@<span class="subst">$&#123;Pkg.version&#125;</span>`</span>, <span class="comment">// 注意这个版本号务必要和 Sentry 收集服务中的 版本号一致！！！！</span></span><br><span class="line">        include: [<span class="string">'dist'</span>],</span><br><span class="line">        ignore: [<span class="string">'node_modules'</span>]</span><br><span class="line">        <span class="comment">// urlPrefix: '~/static/js' // URL前缀，在CDN部署模式下有用</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、上传</p><p>在项目根目录下新建一个 <code>.sentryclirc</code> 文件，此文件为 <code>ini</code> 格式，写入以下配置</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[defaults]</span></span><br><span class="line"><span class="attr">url</span> = &lt;sentry服务器&gt;</span><br><span class="line"><span class="attr">org</span> = &lt;组织&gt;</span><br><span class="line"><span class="attr">project</span> = &lt;项目名&gt;</span><br><span class="line"></span><br><span class="line"><span class="section">[auth]</span></span><br><span class="line"><span class="attr">token</span> = &lt;上传Token&gt;</span><br></pre></td></tr></table></figure><p>具体代表含义可以百度，以上内容均可以在 Sentry 后台中找到，举例如下</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[defaults]</span></span><br><span class="line"><span class="attr">url</span> = https://xxxxx.com/</span><br><span class="line"><span class="attr">org</span> = xxxxx</span><br><span class="line"><span class="attr">project</span> = xxxxx</span><br><span class="line"></span><br><span class="line"><span class="section">[auth]</span></span><br><span class="line"><span class="attr">token</span> = xxxxxx</span><br></pre></td></tr></table></figure><p>进行上述操作之后，即可以执行打包命令，可以看到 sourcemap 上传过程</p><p>3、删除代码包中的 <code>.map</code> 文件</p><p>首先需要安装几个插件（插件有很多，这里只是举例）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i fs-extra glob -D</span><br></pre></td></tr></table></figure><p>在项目打包配置文件中写入如下配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; removeSync &#125; = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.plugins = [</span><br><span class="line">      ...config.plugins,</span><br><span class="line">      &#123;</span><br><span class="line">        apply: <span class="function">(<span class="params">compiler</span>) =&gt;</span> &#123;</span><br><span class="line">          compiler.hooks.done.tap(<span class="string">'CleanJsMapPlugin'</span>, () =&gt; &#123;</span><br><span class="line">            glob.sync(<span class="string">'dist/**/*.js.map'</span>).forEach(<span class="function">(<span class="params">f</span>) =&gt;</span> removeSync(f))</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的配置文件如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SentryWebpackPlugin = <span class="built_in">require</span>(<span class="string">'@sentry/webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> Pkg = <span class="built_in">require</span>(<span class="string">'./package.json'</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; removeSync &#125; = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.plugins = [</span><br><span class="line">      ...config.plugins,</span><br><span class="line">       <span class="keyword">new</span> SentryWebpackPlugin(&#123;</span><br><span class="line">        release: <span class="string">`<span class="subst">$&#123;Pkg.name&#125;</span>@<span class="subst">$&#123;Pkg.version&#125;</span>`</span>, <span class="comment">// 注意这个版本号务必要和 Sentry 收集服务中的 版本号一致！！！！</span></span><br><span class="line">        include: [<span class="string">'dist'</span>],</span><br><span class="line">        ignore: [<span class="string">'node_modules'</span>]</span><br><span class="line">        <span class="comment">// urlPrefix: '~/static/js' // URL前缀，在CDN部署模式下有用</span></span><br><span class="line">      &#125;),</span><br><span class="line">      &#123;</span><br><span class="line">        apply: <span class="function">(<span class="params">compiler</span>) =&gt;</span> &#123;</span><br><span class="line">          compiler.hooks.done.tap(<span class="string">'CleanJsMapPlugin'</span>, () =&gt; &#123;</span><br><span class="line">            glob.sync(<span class="string">'dist/**/*.js.map'</span>).forEach(<span class="function">(<span class="params">f</span>) =&gt;</span> removeSync(f))</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、部署过程略</p><p>进行上述操作后，即可进行打包，部署。</p><p>注意，不同项目的上传 sourcemap 配置并不相同，请勿直接 copy。这里只是提供大概手段以及思路。</p><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>上述我们大致介绍了一下环境配置，实际上，上文的环境配置只能覆盖 <code>development</code> 和 <code>production</code> 这两个环境，更多的环境例如 <code>QA</code>、<code>test</code>、<code>pre-release</code>等并不能覆盖到，因此会导致真正的线上环境和测试环境等混淆在一起无法区分（虽然可以通过触发监控的域名区分，但是并不好，无法做警告通知，数据统计等）。</p><p>接下来我们借助一种骚操作，做到 Sentry 真正的多环境配置，即一次配置，一劳永逸。</p><p>1、静态部署多环境配置（针对<strong>非服务端渲染项目</strong>）</p><p>首先我们需要借助 <code>nginx</code>，为什么要借助 <code>nginx</code> 是因为前端打包后并不能读取环境变量，但是 <code>nginx</code> 可以，我们可以借助 <code>nginx</code> 作为中转，读取环境变量然后返回给我们。先在 <code>nginx</code> 的配置文件中加入 <code>header</code> 头。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意此文件实际上并不是 nginx 配置文件，是一个 nginx template 文件</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(?:htm|html)$</span> &#123;</span><br><span class="line">      <span class="attribute">add_header</span> Cache-Control</span><br><span class="line"></span><br><span class="line">          <span class="string">"private, no-store, no-cache, must-revalidate, proxy-revalidate"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">add_header</span> vue_env <span class="variable">$&#123;VUE_ENV&#125;</span>; <span class="comment"># $&#123;VUE_ENV&#125; 为 nginx 变量</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上述声明中我们不难看出，关键的是指定 <code>${VUE_ENV}</code> 这个变量，这个变量的值会在入口文件的 <code>response header</code> 中体现出来，我们读取即可，而 <code>${VUE_ENV}</code> 则可以不同环境分别指定，或者借助 <code>docker-nginx</code> 动态指定均可。</p><p>然后我们可以读取 <code>response header</code>，获取环境信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">req.open(<span class="string">'GET'</span>, <span class="built_in">window</span>.location.href, <span class="literal">false</span>)</span><br><span class="line">req.send(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> responseHeader = req</span><br><span class="line">  .getAllResponseHeaders()</span><br><span class="line">  .trim()</span><br><span class="line">  .split(<span class="regexp">/[\r\n]+/</span>)</span><br><span class="line">  .reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parts = cur.split(<span class="string">': '</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; ...acc, [parts.shift()]: parts.join(<span class="string">': '</span>) &#125;</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(responseHeader) <span class="comment">// responseHeader 即为响应头</span></span><br></pre></td></tr></table></figure><p>获取到环境信息后，我们可以注入到 Sentry 中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: <span class="string">'此处填写 dsn'</span>,</span><br><span class="line">  environment: responseHeader.vue_env ?? process.env.VUE_APP_SENTRY_ENVIRONMENT,</span><br><span class="line">  release: <span class="string">`<span class="subst">$&#123;Pkg.name&#125;</span>@<span class="subst">$&#123;Pkg.version&#125;</span>`</span>,</span><br><span class="line">  integrations: [</span><br><span class="line">    <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [<span class="string">'localhost'</span>, /^\<span class="comment">//]</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">  <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">  <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">  tracesSampleRate: <span class="number">1.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后部署，即可以看到效果</p><p>2、服务端渲染的多环境配置</p><p>服务端渲染由于有 <code>node</code> 环境，本身支持环境变量注入，即 <code>process.env</code>，因此我们不需要借助 <code>nginx</code>。但是要注意，由于大多数前端框架处理环境变量时候使用的插件是 <code>webpack.DefinePlugin</code>，此插件最大的问题是使用变量替换，这也会导致在应用代码中指定的环境不会再运行时改写。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开发环境</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV) <span class="comment">// development</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产环境</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV) <span class="comment">// production</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试环境</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.NODE_ENV) <span class="comment">// production</span></span><br></pre></td></tr></table></figure><p>因此我们需要改变思路，将环境变量存起来，此处用 <code>Nuxt</code> 项目举例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123; removeSync, writeFileSync, createFileSync &#125; <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然代码很丑 但是可以解决问题 后续再优化代码</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">'./static/env'</span>)</span><br><span class="line">  removeSync(filePath)</span><br><span class="line">  createFileSync(filePath)</span><br><span class="line">  writeFileSync(filePath, process.env.VUE_ENV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即我们写入一个 <code>env</code> 文件，为当前运行环境下的环境变量即可，读取时只需要做如下操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Sentry <span class="keyword">from</span> <span class="string">'@sentry/browser'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Vue <span class="keyword">as</span> VueIntegration &#125; <span class="keyword">from</span> <span class="string">'@sentry/integrations'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Integrations &#125; <span class="keyword">from</span> <span class="string">'@sentry/tracing'</span></span><br><span class="line"><span class="keyword">import</span> Pkg <span class="keyword">from</span> <span class="string">'../package.json'</span></span><br><span class="line"><span class="keyword">import</span> ACTIONS <span class="keyword">from</span> <span class="string">'../util/vuexEvents'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123; isDev, $axios, store &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isDev) &#123;</span><br><span class="line">    $axios.get(<span class="string">'env'</span>, &#123; <span class="attr">baseURL</span>: <span class="string">''</span> &#125;).then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      store.commit(ACTIONS.ENV, data ?? <span class="string">'test'</span>) <span class="comment">// 将环境变量存起来，以防它用</span></span><br><span class="line">      Sentry.init(&#123;</span><br><span class="line">        dsn: <span class="string">'写入你的  dsn'</span>,</span><br><span class="line">        environment: data ?? process.env.NODE_ENV,</span><br><span class="line">        release: <span class="string">`<span class="subst">$&#123;Pkg.name&#125;</span>@<span class="subst">$&#123;Pkg.version&#125;</span>`</span>,</span><br><span class="line">        integrations: [</span><br><span class="line">          <span class="keyword">new</span> VueIntegration(&#123;</span><br><span class="line">            Vue,</span><br><span class="line">            tracing: <span class="literal">true</span></span><br><span class="line">          &#125;),</span><br><span class="line">          <span class="keyword">new</span> Integrations.BrowserTracing(&#123;</span><br><span class="line">            <span class="comment">// routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span></span><br><span class="line">            tracingOrigins: [<span class="string">'localhost'</span>, /^\<span class="comment">//]</span></span><br><span class="line">          &#125;)</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// Set tracesSampleRate to 1.0 to capture 100%</span></span><br><span class="line">        <span class="comment">// of transactions for performance monitoring.</span></span><br><span class="line">        <span class="comment">// We recommend adjusting this value in production</span></span><br><span class="line">        tracesSampleRate: <span class="number">1.0</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以看到效果</p><h2 id="initialScope"><a href="#initialScope" class="headerlink" title="initialScope"></a>initialScope</h2><p>上述介绍了 Sentry 大体的接入流程，但是针对于某些特定场景，我们仅仅监控到错误还不够，特别是对于一些硬件设备，我们需要知道业务的标注信息，以方便及时警告。幸运的是 Sentry 为我们提供了此功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  dsn: <span class="string">"https://examplePublicKey@o0.ingest.sentry.io/0"</span>,</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  initialScope: &#123;</span><br><span class="line">    tags: &#123;<span class="string">"my-tag"</span>: <span class="string">"my value"</span>&#125;,</span><br><span class="line">    user: &#123;<span class="attr">id</span>: <span class="number">42</span>, <span class="attr">email</span>: <span class="string">"john.doe@example.com"</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  dsn: <span class="string">"https://examplePublicKey@o0.ingest.sentry.io/0"</span>,</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  initialScope: <span class="function"><span class="params">scope</span> =&gt;</span> &#123;</span><br><span class="line">    scope.setTags(&#123; <span class="attr">a</span>: <span class="string">'b'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>两种方式均可，添加了自定义 <code>tag</code> 之后，在性能监控，错误监控下，都会有自定义的 <code>tag</code> 出现，如下图</p><p><img src="//jdeseva.github.io/2022/01/05/Sentry/QQ%E6%88%AA%E5%9B%BE20220105171016.png" alt="tag"></p><p>这样我们可以自定义相应的 <code>tag</code> 信息，以方便我们进行问题定位</p><blockquote><p><strong>注意，<code>tag</code> 不是越多越好，自定义标注内容也是，尽量简洁明了，亢余的信息我们不应该传递，应该根据实际业务需求传递。</strong></p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>未完待续</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> frame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI/CD之容器化</title>
      <link href="/2021/09/28/CI-CD%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
      <url>/2021/09/28/CI-CD%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="CI-CD之容器化"><a href="#CI-CD之容器化" class="headerlink" title="CI/CD之容器化"></a>CI/CD之容器化</h1><p>自古以来，程序猿最头痛的事情就是环境配置，有相当一部分的程序，只能运行在特定环境上，比如<code>sketch</code>只支持Mac。那么我怎么做到别的环境也能运行这个程序？并且原封不动的保证功能完好？答案大概只有容器化。</p><blockquote><p>容器化，大体上指将服务，代码等运行在一个容器中，也可以理解为一个沙箱。在前端服务越发复杂的今天，容器化的推进将直接关乎前端发布部署的体验以及后续维护成本的高低。</p></blockquote><p>容器化有不少技术，包括虚拟机，<code>Docker</code>等等。</p><p>在 <code>Docker</code> 技术成熟的今天，容器化大部分都是由 <code>Docker</code> 体系为基础构建。<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">什么是<code>Docker</code>?</a>，可以提供参考。</p><a id="more"></a><h2 id="发布模式"><a href="#发布模式" class="headerlink" title="发布模式"></a>发布模式</h2><p>首先我们联系一下在没有容器化情况下的开发模式，大体如下</p><ul><li>推送代码</li><li>打包构建</li><li>发布到服务器</li><li>配置<code>nginx</code>代理</li></ul><p>按照正常情况下，服务器上只会存在一个 <code>nginx</code>，如果前端项目无限扩充，那么<code>nginx</code>配置文件将会乱做一团糟（尤其是没有配置<code>nginx</code>模块化配置的情况下）</p><p>如果切换到容器化的发布模式，将优化为以下两步</p><ul><li>构建容器</li><li>运行容器</li></ul><p>乍一看可能没什么大的优点，但是如果需要环境迁移，分布式部署，以及单一版本验证等场景下，容器化将是普通发布模式无可替代的。</p><h2 id="Docker-入门"><a href="#Docker-入门" class="headerlink" title="Docker 入门"></a>Docker 入门</h2><blockquote><p>Docker是一个开源的商用技术，在此只讨论社区版（<del>贫穷使我理智</del>）。</p></blockquote><p>我们这里需要首先了解几个概念</p><ul><li>宿主机</li><li>镜像</li><li>容器</li><li>标签</li></ul><p>宿主机，顾名思义，指的是容器运行所依赖的环境，说白了，就是你部署服务的地方，可以是Windows，也可以是Linux，还可以是Mac。</p><p>镜像（<code>images</code>），在<code>Docker</code>体系下，指的是应用以及依赖等打包成一个二进制文件，一个镜像可以引用另外一个镜像，注意，<code>Docker</code>不支持按需引入嗷，因此为了保证最后执行的镜像文件尽可能小，我们在选择基础镜像的时候尤其注意。</p><p>容器（<code>container</code>），将镜像配合一系列的参数命令执行后会生成一个容器，这个容器就是你代码应用运行的地方，是一个独立的环境，内部环境由你所依赖的基础镜像决定，可以理解为沙箱。</p><p>标签（<code>TAG</code>），即版本号，最新的默认为 <code>latest</code>，<code>latest</code>可以省略。</p><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>自己百度，注意如果是 Linux 环境，记得安装 docker-compose。Windows桌面版已经自动集成，不用额外安装。</p><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><p>可以简单把<code>Docker</code>理解为 npm</p><p><code>npm</code> 包含拉取依赖，推送依赖的功能，因此 <code>Docker</code> 也有，即 <code>pull</code>， <code>push</code>。</p><p><code>npm</code> 有仓库概念，因此 <code>Docker</code> 也有，<a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a></p><blockquote><p><code>Docker</code> 常用命令如下</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 拉取一个镜像</span><br><span class="line"></span><br><span class="line">docker pull &lt;IMAGE&gt;:&lt;TAG&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打标签</span><br><span class="line"></span><br><span class="line">docker tag &lt;IMAGE&gt;:&lt;OLDTAG&gt; &lt;IMAGE&gt;:&lt;NEWTAG&gt; # 可以理解为重命名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 推送镜像</span><br><span class="line"></span><br><span class="line">docker push &lt;REGISTRY&gt;/&lt;IMAGE&gt;:&lt;TAG&gt; # 类似于推送 npm 包</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>我们要运行我们的代码环境，首先就得制作一个镜像，上文也说到，镜像是应用代码和依赖等打包成一个二进制文件，并且还可以引用别的镜像从而获得别的镜像的全部功能。</p><p>那么我们将一个简单的由一个Vue项目打包出来的静态项目打包成镜像。</p><p>首先我们思考一下平常发布模式下我们会怎么做，结合上述发布模式，大致为</p><ul><li>推送代码</li><li>打包构建</li><li>发布到服务器</li><li>配置<code>nginx</code>代理</li></ul><p>那么我们逐步拆解，首先手动打包，会生成一个<code>dist</code>文件夹，我们接下来要做的，就是将这个打包生成的文件，添加打包成一个镜像。</p><p>新建一个 <code>Dockerfile</code> 文件（注意没有后缀），写入以下内容</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> mkdir /app # 创建文件夹</span><br><span class="line"><span class="keyword">COPY</span> /dist /app # 复制文件</span><br></pre></td></tr></table></figure><p>上述操作后，我们就将我们的代码包拷贝到了镜像中，接下来执行以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker build . -t &lt;IMAGE&gt;:&lt;TAG&gt;</span><br></pre></td></tr></table></figure><p>执行完毕之后，就会开始镜像构建，完成后可以使用 <code>docker images</code> 查看构建的镜像，类似于下面</p><p><img src="//jdeseva.github.io/2021/09/28/CI-CD之容器化/QQ%E6%88%AA%E5%9B%BE20210928175249.png" alt="docker images"></p><p>但是实际上我们上述操作的镜像还是不能运行的，结合发布模式我们不难看到，我们还需要一个 <code>nginx</code> 做静态资源服务器，做资源代理。</p><p>因此，在项目下新建一个 <code>nginx.conf</code> 文件，作为 nginx 的配置文件，写入以下内容</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span> main</span><br><span class="line"></span><br><span class="line">        <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">        <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">        <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/javascript text/css;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 虚拟主机server块</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">4000</span>;</span><br><span class="line">        <span class="comment"># 匹配请求中的host值</span></span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /app;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(?:js|css)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(?:htm|html)$</span> &#123;</span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control</span><br><span class="line"></span><br><span class="line">                <span class="string">"private, no-store, no-cache, must-revalidate, proxy-revalidate"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /app;</span><br><span class="line">            <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">            <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:stable <span class="comment"># 我们选择 stable 版本的 nginx 镜像</span></span><br><span class="line"><span class="keyword">RUN</span> mkdir /app # 创建文件夹</span><br><span class="line"><span class="keyword">COPY</span> /dist /app # 复制文件</span><br><span class="line"><span class="keyword">COPY</span> nginx.conf /etc/nginx/templates/default.template</span><br></pre></td></tr></table></figure><p>然后重新构建镜像，执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker build . -t test</span><br></pre></td></tr></table></figure><p>执行完毕之后，然后运行镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name test -d test # --name 指定容器名称 -d 后台运行容器</span><br></pre></td></tr></table></figure><p>然后打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到运行的项目</p><h2 id="Docker进阶"><a href="#Docker进阶" class="headerlink" title="Docker进阶"></a>Docker进阶</h2><blockquote><p>敬请期待！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> frame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范细则</title>
      <link href="/2019/10/10/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%BB%86%E5%88%99/"/>
      <url>/2019/10/10/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%BB%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="前端代码规范细则"><a href="#前端代码规范细则" class="headerlink" title="前端代码规范细则"></a>前端代码规范细则</h3><p>本细则分为强制和非强制内容，欢迎提出 issue</p><h4 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h4><ul><li><p>强制使用<code>eslint</code></p></li><li><p>函数注释强制使用<code>jsDoc</code>注释，即 <code>/**</code> 开头的注释格式</p></li><li><p>代码结尾一律不得加<code>;</code>，此项可以由<code>prettier</code>格式化工具自动实现</p></li><li><p>字符串一律使用单引号<code>&#39;&#39;</code>，多行字符串一律使用模板字符串</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">`adf</span></span><br><span class="line"><span class="string">dasd</span></span><br><span class="line"><span class="string">888</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>不得使用<code>eval</code></p></li><li><p>不得使用<code>==</code>，一律使用<code>===</code>，<code>!==</code></p></li><li><p>对象（包含数组）格式，逗号，冒号后面需要留空格，运算符前后需要留空格。此项也可以由代码格式化工具实现，注意即可</p></li></ul><blockquote><p>例子如下</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">c</span>: <span class="number">7</span>, <span class="attr">d</span>: <span class="number">9</span> &#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">8</span> * <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li><p>不得使用<code>delete</code>关键字删除对象属性，如确需需要删除属性，使用<code>Reflect.deleteProperty</code>进行操作</p></li><li><p>不得使用隐式转换进行代码运算操作，例如</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> + <span class="string">'e'</span> <span class="comment">// '100e'</span></span><br></pre></td></tr></table></figure><ul><li><p>函数命名务必简洁明了，力求能通过函数名得出函数作用，减少无关注释</p></li><li><p>公共函数一律使用<code>__</code>开头命名，并且首字母大写，例如</p></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; method 事件触发的操作,fn</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; [delay = 500] - delay 多少毫秒内连续触发事件，不会执行</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">__Debounce</span>(<span class="params">method: <span class="built_in">Function</span>, delay: <span class="built_in">number</span> = 500</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      method.apply(self, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>拥有返回值的函数必须考虑<strong>边界情况</strong>，不得存在边界条件下没有返回值的情况</p></li><li><p>使用<code>import</code>语法不得使用<code>import * as</code>结果语法，确需引用多个，请使用解构语法</p></li><li><p>DOM 对象不得使用数组储存，一律使用<code>WeakMap</code>和<code>WeakSet</code></p></li><li><p>数组存储数据不得超出数组长度，js 数组最大长度为 0xFFFFFFFF = 4294967295</p></li><li><p>错误处理</p></li><li><p>不得轻易修改函数原型，确需修改，则不应向用户暴露接口</p></li></ul><h4 id="非强制"><a href="#非强制" class="headerlink" title="非强制"></a>非强制</h4><ul><li><p>推荐使用 Typescript</p></li><li><p>解构语法、对象等首尾留空，例如</p></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Vue, Provide, Watch &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span></span><br></pre></td></tr></table></figure><ul><li><p>对象键名不使用数字</p></li><li><p>能使用箭头函数<code>=&gt;</code>，就不用普通函数</p></li><li><p>能使用<code>es6</code>新特性就用新特性</p></li><li><p>递归尽量使用尾递归</p></li><li><p>对象浅复制，对象合并尽量使用扩展运算符<code>...</code></p></li><li><p>取整少用<code>parseInt</code></p></li><li><p>少用<code>try{}catch(e){}</code>语法</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端开发流程规范</title>
      <link href="/2019/10/09/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
      <url>/2019/10/09/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前端开发流程规范"><a href="#前端开发流程规范" class="headerlink" title="前端开发流程规范"></a>前端开发流程规范</h1><blockquote><p>本规范处于试行阶段，欢迎提出 issue</p></blockquote><p>本流程规范暂定下列三个规范，涵盖方方面面。如有异议，可以提出修改意见。集思广益，方得始终。</p><h2 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h2><p>流程规范主要指<strong>开发流程</strong>的规范，此规范需要配合前端、后端、设计、产品、测试、运维等必要环节，分为<strong>开发前规范</strong>和<strong>开发阶段规范</strong>两个部分。</p><h4 id="开发前规范"><a href="#开发前规范" class="headerlink" title="开发前规范"></a>开发前规范</h4><p>开发前首先应当<strong>十分确定产品需求、服务人群、开发周期、开发模式等一系列要素</strong>，其中<strong>产品需求、服务人群</strong>应当由产品、运维等进行把控，新产品开发前<strong>必须</strong>进行<strong>产品研讨会</strong>，相关人员应当到场（前端、后端、设计、产品、测试、运维等必要环节相关人员），进行<strong>产品论证</strong>，论证通过则<strong>产品应当书写产品文档，包含设计文档，开发规划等相关信息</strong>，交由领导审核，通过进入下一步，不通过打回研讨，直至通过。</p><p>开发前流程走完之后，进入开发阶段规范</p><a id="more"></a><h4 id="开发阶段规范"><a href="#开发阶段规范" class="headerlink" title="开发阶段规范"></a>开发阶段规范</h4><p>在<strong>正式产品设计文档、开发规划等文档</strong>确立下发后，<strong>所有负责产品</strong>（<strong>项目</strong>，后文用项目代替）的前端、后端开发人员，应当参加项目开发前会议。该会议主要探讨以下内容</p><ul><li><p>项目技术选型</p></li><li><p>项目功能分块</p></li><li><p>功能结构任务划分</p></li><li><p>功能结构任务相应开发时间（此时间不包含测试时间，需要对应负责的前端、后端自行预估）</p></li><li><p>单元测试和联合测试</p></li></ul><blockquote><p>以上时间均不包含测试时间</p></blockquote><p>以上流程走完，进入项目开发过程</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>本规范主要在开发过程中，包含强制执行内容和非强制执行内容</p><h4 id="强制内容"><a href="#强制内容" class="headerlink" title="强制内容"></a>强制内容</h4><ul><li><p>强制使用 <code>eslint</code>作为代码规范检查</p></li><li><p>强制使用 <code>prettier</code>作为代码格式化插件</p></li><li><p>强制使用<code>yarn</code>作为开发过程中架包管理工具</p></li><li><p>不得使用<code>git</code>命令行进行代码提交推送（回退，<code>rebase</code>等除外）</p></li><li><p>函数注释强制使用多行注释，并且遵守<code>jsDoc</code>规范</p></li></ul><blockquote><p>具体举例如下</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; method 事件触发的操作,fn</span></span><br><span class="line"><span class="comment"> * @param &#123;Number&#125; [delay = 500] - delay 多少毫秒内连续触发事件，不会执行</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">__Debounce</span>(<span class="params">method: <span class="built_in">Function</span>, delay: <span class="built_in">number</span> = 500</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer: <span class="built_in">number</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      method.apply(self, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非强制内容"><a href="#非强制内容" class="headerlink" title="非强制内容"></a>非强制内容</h4><ul><li><p>推荐使用 soureTree 进行代码推送</p></li><li><p>推荐使用 vscode 作为开发工具</p></li><li><p>推荐使用 Typescript 作为开发语言（视团队具体情况）</p></li></ul><blockquote><p>详细代码规范细则见<a href="/2019/10/10/代码规范细则">《代码规范细则》</a></p></blockquote><h2 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a>提交规范</h2><p>代码提交规范包含以下几个部分</p><ul><li><p><code>commit</code> 规范</p></li><li><p>合并代码规范</p></li><li><p>代码推送规范</p></li></ul><h4 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h4><p>commit 规范代表每次提交时的附带信息（Commit message）。主要包含以下三个部分</p><ul><li><p>header</p></li><li><p>body</p></li><li><p>footer</p></li></ul><p>其中，header 是<strong>必填</strong>的，Header 部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subjec</code>t（必需）</p><p><strong>type</strong></p><p>用于说明 commit 的类别，只允许使用下面 7 个标识。</p><ul><li><p>feat：新功能（feature）</p></li><li><p>fix：修补 bug</p></li><li><p>docs：文档（documentation）</p></li><li><p>style： 格式（不影响代码运行的变动）</p></li><li><p>refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）</p></li><li><p>test：增加测试</p></li><li><p>chore：构建过程或辅助工具的变动</p></li></ul><p><strong>scope</strong></p><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p>例如在<code>Vue</code>中，影响视图层则标识符为 View，更新<code>Vuex</code>不影响视图则为 Controller，更新组件而不影响其他则为 Model 等等。</p><p>如果你的修改影响了不止一个<code>scope</code>，你可以使用*代替。</p><p><strong>subject</strong></p><p><code>subject</code> 是 commit 目的的简短描述，不超过 50 个字符。</p><p>其他注意事项：</p><ul><li>结尾不加句号</li></ul><blockquote><p>更具体的 commit 规范 详情查看<a href="https://www.jianshu.com/p/201bd81e7dc9?utm_source=oschina-app" target="_blank" rel="noopener">这篇文章</a></p></blockquote><h4 id="代码合并规范"><a href="#代码合并规范" class="headerlink" title="代码合并规范"></a>代码合并规范</h4><p>代码合并规范又称为<strong>分支合并规范</strong></p><p>为了得到清晰的分支历史，在进行分支合并的时候有两点规范需要注意：</p><ul><li><p>所有分支的合并都采用非快进模式，必须再次创建一个提交（commit），以进行合并</p></li><li><p>所有非<code>master</code>分支只能通过定期同步<code>master</code>分支来获取最新代码，不得通过直接合并其他分支来实现代码同步</p></li></ul><p>git 分支规范</p><table><thead><tr><th>名称</th><th>说明</th><th>命名规范</th><th>命名示例</th><th>合并目标</th><th>合并操作</th></tr></thead><tbody><tr><td>master</td><td>主分支，线上稳定版本</td><td>master</td><td>master</td><td>–</td><td>–</td></tr><tr><td>release</td><td>待发布(通过稳定测试)分支，下个版本需上线的版本，发布之后及时删除即可</td><td>release/xxx</td><td>release/v1.0.0</td><td>master</td><td>merge request</td></tr><tr><td>develop</td><td>当前正在开发的分支，测试分支</td><td>develop</td><td>develop</td><td>master</td><td>merge request</td></tr><tr><td>feature</td><td>功能分支，每个功能需分别建立自己的子分支，<strong>开发完毕需要删除</strong></td><td>feature/版本号-功能名</td><td>feature/v1.0.0-Login</td><td>develop</td><td>merge request</td></tr><tr><td>hotfix</td><td>紧急修复分支</td><td>hotfix/xxx</td><td>hotfix/v1.0.1</td><td>master/develop</td><td>merge request</td></tr></tbody></table><p>git 流程图如下</p><p><img src="//jdeseva.github.io/2019/10/09/前端开发流程规范/git.jpg" alt="git分支流程图"></p><blockquote><p>代码合并前尽量保证 commit 的整洁，如有条件可以使用 <code>git rebase</code>命令。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由filter说开去</title>
      <link href="/2019/08/13/%E7%94%B1filter%E8%AF%B4%E5%BC%80%E5%8E%BB/"/>
      <url>/2019/08/13/%E7%94%B1filter%E8%AF%B4%E5%BC%80%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>filter</code> 这个函数，相信大家都不会陌生，他是 es2015 新增的数组的方法，用以过滤。它接受一个函数，返回符合函数条件的数组，如果没有，则返回空数组。</p><p>语法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure><p>各个参数的具体含义如下（来源于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="noopener">MDN</a>）</p><blockquote><p><strong>callback</strong><br>用来测试数组的每个元素的函数。返回 <code>true</code> 表示该元素通过测试，保留该元素，<code>false</code> 则不保留。它接受以下三个参数：<br><strong>element</strong><br>数组中当前正在处理的元素。<br><strong>index</strong> 可选<br>正在处理的元素在数组中的索引。<br><strong>array</strong> 可选<br>调用了 <code>filter</code> 的数组本身。<br><strong>thisArg</strong> 可选<br>执行 <code>callback</code> 时，用于 <code>this</code></p></blockquote><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>filter</code> 是一个基础的数组操作用法，它的基本用法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//过滤普通数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="params">row</span> =&gt;</span> row &gt; <span class="number">4</span>) <span class="comment">// [5, 6, 7, 5, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤对象数组</span></span><br><span class="line"><span class="keyword">var</span> data = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = data.filter(<span class="function"><span class="params">row</span> =&gt;</span> row.a === <span class="number">1</span>) <span class="comment">// [&#123;a: 1, b: 4&#125;]</span></span><br></pre></td></tr></table></figure><p>当然，它还可以和别的东西结合起来，比如取数组交集</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取交集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;array&#125;</span> <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">__Union</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.filter(<span class="function"><span class="params">v</span> =&gt;</span> b.includes(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个-bug-引发的思考"><a href="#一个-bug-引发的思考" class="headerlink" title="一个 bug 引发的思考"></a>一个 bug 引发的思考</h3><p>接下来切入正题，之前 review 代码，然后发现了一个关于 <code>filter</code> 的 bug，bug 的原因很简单，写错了 <code>filter</code>传入的函数的判断体。大致代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = data.filter(<span class="function"><span class="params">row</span> =&gt;</span> (row.a = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>相信各位同学一眼就能看出问题所在，的确就是判断的 <code>===</code>写成了<code>=</code></p><p>那么问题来了，这个<code>res</code>的结果是多少，各位同学知道吗？是空数组？还是报错(<code>Uncaught SyntaxError: Unexpected token</code>)？</p><p>不知道的同学可以尝试一下，结果其实是下面这样子的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = data.filter(<span class="function"><span class="params">row</span> =&gt;</span> (row.a = <span class="number">1</span>)) <span class="comment">// [&#123;a: 1, b: 4&#125;, &#123;a: 1, b: 8&#125;]</span></span><br></pre></td></tr></table></figure><p>？？？？我们再来打印一下原始数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = data.filter(<span class="function"><span class="params">row</span> =&gt;</span> (row.a = <span class="number">1</span>)) <span class="comment">// [&#123;a: 1, b: 4&#125;, &#123;a: 1, b: 8&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">// [&#123;a: 1, b: 4&#125;, &#123;a: 1, b: 8&#125;]</span></span><br></pre></td></tr></table></figure><p>嗯？很奇怪是不是，难不成返回了原数组？我们接下来继续判断一下是不是原数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = data.filter(<span class="function"><span class="params">row</span> =&gt;</span> (row.a = <span class="number">1</span>)) <span class="comment">// [&#123;a: 1, b: 4&#125;, &#123;a: 1, b: 8&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">// [&#123;a: 1, b: 4&#125;, &#123;a: 1, b: 8&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data === v) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>看到这里，我们可以发现，这个问题不是<code>filter</code>返回了原始数组，所以并不是 bug，那么究竟是什么原因导致的问题呢？我们继续往下看。</p><h3 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h3><p>分析此类问题，最好的办法还是查看源码，既然<code>filter</code>是 es2015 新增的特性，那么，必然会有 Polyfill 对其进行向下兼容。于是我们翻看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill" target="_blank" rel="noopener">MDN</a>，找到如下代码</p><blockquote><p>注：<code>filter</code> 被添加到 ECMA-262 标准第 5 版中，因此在某些实现环境中不被支持。可以把下面的代码插入到脚本的开头来解决此问题，该代码允许在那些没有原生支持 <code>filter</code> 的实现环境中使用它。该算法是 ECMA-262 第 5 版中指定的算法，假定 <code>fn.call</code> 等价于 <code>Function.prototype.call</code>的初始值，且 <code>Array.prototype.push</code> 拥有它的初始值。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.filter) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span>(<span class="params">func, thisArg</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">if</span> (!((<span class="keyword">typeof</span> func === <span class="string">'Function'</span> || <span class="keyword">typeof</span> func === <span class="string">'function'</span>) &amp;&amp; <span class="keyword">this</span>))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>, <span class="comment">// 无符号右移0，详情见注[1]</span></span><br><span class="line">      res = <span class="keyword">new</span> <span class="built_in">Array</span>(len), <span class="comment">// preallocate array</span></span><br><span class="line">      t = <span class="keyword">this</span>,</span><br><span class="line">      c = <span class="number">0</span>,</span><br><span class="line">      i = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (++i !== len) &#123;</span><br><span class="line">        <span class="comment">// checks to see if the key was set</span></span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (func(t[i], i, t)) &#123;</span><br><span class="line">            res[c++] = t[i]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (++i !== len) &#123;</span><br><span class="line">        <span class="comment">// checks to see if the key was set</span></span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (func.call(thisArg, t[i], i, t)) &#123;</span><br><span class="line">            res[c++] = t[i]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.length = c <span class="comment">// shrink down array to proper size</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>从上面的代码我们可以很明显的看出，过滤操作主要发生在<code>while</code>循环内，首先先判断<code>func(t[i], i, t)</code>是否为<code>true</code>，如果是，则将此项复制一份到<code>res</code>中，最后循环结束，返回<code>res</code></p><p>整个 Polyfill 思路清晰，我们可以得出一点，就是之前的问题，原因产生在下面这段代码中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (func(t[i], i, t)) &#123;</span><br><span class="line">  res[c++] = t[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实际情况，我们可以得出以下假设</p><blockquote><p><code>if</code>函数体判断一直为<code>true</code>，然后函数体再对原始数组进行修改，导致，返回结果与原数组一样（注意，这里的原数组指的是修改之后的）</p></blockquote><p>我们尝试在<code>Array</code>上挂载一个<code>filters</code>的方法（做一个对比，不覆盖原有的<code>filter</code>方法），代码就为上述 Polyfill 的代码（加上了两句<code>console.log</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.filters) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.filters = <span class="function"><span class="keyword">function</span>(<span class="params">func, thisArg</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">if</span> (!((<span class="keyword">typeof</span> func === <span class="string">'Function'</span> || <span class="keyword">typeof</span> func === <span class="string">'function'</span>) &amp;&amp; <span class="keyword">this</span>))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>, <span class="comment">// 无符号右移0，详情见注[1]</span></span><br><span class="line">      res = <span class="keyword">new</span> <span class="built_in">Array</span>(len), <span class="comment">// preallocate array</span></span><br><span class="line">      t = <span class="keyword">this</span>,</span><br><span class="line">      c = <span class="number">0</span>,</span><br><span class="line">      i = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (++i !== len) &#123;</span><br><span class="line">        <span class="comment">// checks to see if the key was set</span></span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (func(t[i], i, t)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(func, func(t[i], i, t))</span><br><span class="line">            res[c++] = t[i]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (++i !== len) &#123;</span><br><span class="line">        <span class="comment">// checks to see if the key was set</span></span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (func.call(thisArg, t[i], i, t)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(func, func(t[i], i, t))</span><br><span class="line">            res[c++] = t[i]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.length = c <span class="comment">// shrink down array to proper size</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = [&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;]</span><br><span class="line"><span class="keyword">var</span> v = data.filters(<span class="function"><span class="params">row</span> =&gt;</span> (row.a = <span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(data, v)</span><br></pre></td></tr></table></figure><p>上面这段代码和我们之前的 bug 结果一样，那我们再改一下，把最后函数体改为 <code>row =&gt; (row.a = 0)</code>，然后你会发现，返回的是一个空数组。Why?</p><p>这里需要说明的就是 JavaScript 的类型转换规则了，我们翻看红宝书，可以得到下列对于<code>Boolean</code>转换规则</p><table><thead><tr><th>数据类型</th><th>转换为<code>true</code></th><th>转换为<code>false</code></th></tr></thead><tbody><tr><td><code>Boolean</code></td><td><code>true</code></td><td><code>false</code></td></tr><tr><td><code>String</code></td><td>任何非空字符串</td><td><code>&#39;&#39;</code>(空字符串)</td></tr><tr><td><code>Number</code></td><td>任何非零数值(包括无穷)</td><td><code>0</code>和<code>NaN</code></td></tr><tr><td><code>Object</code></td><td>任何对象</td><td><code>null</code></td></tr><tr><td><code>Undefined</code></td><td><code>n/a</code>(<code>N/A</code>代表不适用)</td><td><code>undefined</code></td></tr></tbody></table><p>我们还是会有一个疑问，为什么 <code>row =&gt; (row.a = 0)</code> 这段函数体调用打印结果和最后赋值有关？</p><p>我们接着尝试</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (row.a = <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test(&#123; <span class="attr">a</span>: <span class="number">-1</span>, <span class="attr">b</span>: <span class="number">8</span> &#125;)) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>下面还有个例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((obj.a = <span class="number">-1</span>)) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;a: -1&#125;</span></span><br></pre></td></tr></table></figure><p>这个问题，我们回到表达式上面来，JS 中表达式分为两种，<strong>单值表达式</strong>和<strong>复合表达式</strong></p><blockquote><p>这里得感谢<a href="https://github.com/mutoe" target="_blank" rel="noopener">mutoe</a>大佬的提点，我也算查漏补缺了…</p></blockquote><blockquote><p><code>JavaScript</code> 表达式<strong>总有</strong>返回值，其中，<strong>单值表达式</strong>的结果是值本身，其他表达式结果是根据运算符进行运算的结果值</p></blockquote><p>于是，上面的一切我们都可以解释的通了，因为我们传入的函数体 <code>row =&gt; (row.a = 0)</code>包含一个<strong>单值表达式</strong>，所以它相当于 <code>row =&gt; return 0</code></p><p>还剩下最后一个问题，关于原始数组的修改。其实这个问题很好理解，因为传入的是对象类型，JS 的对象类型都是由引用地址进行传递，如果没有进行<strong>深拷贝</strong>，那么它所传递的就是一个<strong>堆地址</strong>的一个指针。所以，修改传递进来的对象，原始数组也会修改（因为说到底，内存的<strong>堆区域</strong>，就只有一个数组）</p><p>可以参考下面的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objc = &#123; <span class="attr">a</span>: <span class="number">77</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">  param.a = <span class="number">100</span></span><br><span class="line">  <span class="keyword">return</span> param</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = test(objc)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// &#123;a: 100&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objc) <span class="comment">// &#123;a: 100&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res === objc) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>接下来，我们做一个总结，为什么<code>filter</code>传入的函数体写法错误（比如传入<code>row =&gt; row.a = 1</code>），会导致原始结果改变</p><blockquote><p>根本原因是由于 <code>filter</code> 的实现过程，决定了输出结果由<strong>传入函数</strong>决定，而函数的输出（<code>return</code>）结果，则由<strong>函数体内部运算</strong>决定，当内部是一个<strong>单值表达式</strong>的时候，由于 JS 表达式的返回值，它会返回值本身，然后函数也返回这个结果，进而进入<code>if</code>判断，接着由于 JS 的 <code>Boolean</code> 类型转换规则，输出 <code>true</code>/<code>false</code>，然后得到意外的结果。而这个过程中，如果传入的数组是一个<strong>对象数组</strong>，那么原始的结果会进行改变，如果不是，那么将会得到原数组的一份拷贝（见下面代码）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = arr.filter(<span class="function"><span class="params">row</span> =&gt;</span> (row = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr === res) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>没想到一个小小的 <code>filter</code>，由一次 bug 引发了诸多思考，尽管个人认为<code>filter</code>的规范里面应该将上面 bug 操作进行<code>Uncaught SyntaxError: Unexpected token</code>报错，但是进而思考，它并不能检测函数体内部（或许可以，但是很麻烦，实现起来也并不现实），因而，我们实际使用中还是要多多注意细节问题。</p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>[1]<a href="https://segmentfault.com/a/1190000014613703" target="_blank" rel="noopener">无符号右移 0 操作</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo更换主题&amp;部署&amp;自动开启issue评论</title>
      <link href="/2019/08/08/Hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98-%E9%83%A8%E7%BD%B2-%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AFissue%E8%AF%84%E8%AE%BA/"/>
      <url>/2019/08/08/Hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98-%E9%83%A8%E7%BD%B2-%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AFissue%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>什么是 Hexo？</p><p>Hexo 一个基于 Node.js 的静态博客写作工具（大致可以这么理解），轻量，方便，<del>高逼格</del>是其最大的优点。它的主要特点就是将我们书写的 markdown 文档转化为页面，然后可以由我们自由部署到个人的服务器，或者 Github Page。</p><h3 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h3><p>Hexo 具体如何使用，网络上有很多文章，这边也不一一列举。推荐一下<a href="https://github.com/mutoe" target="_blank" rel="noopener">mutoe</a>写的博客。</p><blockquote><p><a href="https://blog.mutoe.com/2016/github-pages-hexo-blog/" target="_blank" rel="noopener">使用 GitHub Pages 和 Hexo 搭建自己的静态博客</a></p></blockquote><h3 id="Hexo-更换主题"><a href="#Hexo-更换主题" class="headerlink" title="Hexo 更换主题"></a>Hexo 更换主题</h3><p>当我们照着<a href="https://github.com/mutoe" target="_blank" rel="noopener">mutoe</a>的文章初始化之后，并且通过 hexo server 运行本地服务之后，就会发现 Hexo 的默认主题，很古老，<del>有点呆板</del>。作为前端 + 强迫症，我并不能接受这种主题，好在 Hexo 给我们提供了更换主题的功能（这也是我觉得 Hexo 最 Nice 的地方!）。</p><a id="more"></a><p>Hexo 社区给我们提供了许多可选主题（感谢这些主题的开发者们，让我们能自己挑选自己喜欢的博客主题！），所有的主题列表可以参考<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo 主题</a>。</p><p>Hexo 更换主题很简单，只需要通过 git clone 命令，将自己喜欢的主题文件 clone 到根目录下面的 themes 文件夹下，然后修改根目录下面的 _config.yml ，找到 theme 选项，将其改为你 clone 下来的主题文件的包名，例如</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/theme.png" alt="Hexo更换主题配置"></p><blockquote><p>之后文章均以 melody 主题作为替换之后的主题</p></blockquote><p>当然，Hexo 配置也有几个比较坑爹的地方，比如配置文件中的 keywords，它接受一个数组，但是！！！重点来了， .yml 文件的数组格式是下面这个样子的</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/keyword.png" alt="keyword配置"></p><blockquote><p>如果不按照上面的格式配置 .yml 的数组就会构建报错</p></blockquote><p>配置完这些，然后确认主题文件所需求的依赖都已经安装完毕，我们就可以愉快的把更换主题之后的 Hexo 跑起来了。</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/Home.png" alt="melody主题"></p><blockquote><p>这里插播一个安利，安利一首歌，也是我的博客名字，来自歌手青山テルマ的<a href="https://music.163.com/#/search/m/?s=%E3%81%9D%E3%81%B0%E3%81%AB%E3%81%84%E3%82%8B%E3%81%AD&type=1&market=baiduqk" target="_blank" rel="noopener">そばにいるね</a>。真的很好听！！！</p></blockquote><blockquote><p>很多主题都为使用者提供了丰富的插件配置项，使用者可以自由配置。<br>melody 也一样，具体可以参考<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/" target="_blank" rel="noopener">melody 文档</a></p></blockquote><h3 id="Hexo-开启评论功能"><a href="#Hexo-开启评论功能" class="headerlink" title="Hexo 开启评论功能"></a>Hexo 开启评论功能</h3><p>首先此功能多数是主题附带的功能，当然也可以独立配置评论插件（这个过程可能会很繁琐）。</p><p>这里我们使用 melody 附带的<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/third-party-support.html#%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">评论系统</a>，它支持很多的评论插件，这里使用<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>。</p><p>首先根据 gitalk 官方的说明<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">文档</a>，我们需要去<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">github 申请</a>一下对应的<strong>GitHub Application</strong>。</p><p>申请完毕之后，我们按照 Hexo 文档配置 gitalk，在主题下面的 _config.yml 中找到下面这段配置，输入自己的信息即可</p><blockquote><p>强烈推荐在 source 文件夹下面新建_data 文件后创建 melody.yml ，然后复制<strong>主题文件夹下</strong>的（划重点） _config.yml 内容到 melody.yml ，之后所有关于主题的配置均在 melody.yml 下配置修改即可，且可以做到平滑升级。</p></blockquote><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">你的client</span> <span class="string">id</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">你的client</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">你的github仓库</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">你的github用户名</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">该仓库的拥有者或协作者</span></span><br></pre></td></tr></table></figure><p>配置完以上内容之后，博客的评论系统正常是可以使用了，大概样子如下</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/gitalk.png" alt="gitalk"></p><p>但是我们忽略了一点，因为 gitalk 的评论内容是基于 github issue 的，但是 github 的内容不会主动创建 issue，所以，我们就需要写一个博客，自己去创建 issue。。。。</p><h3 id="自动创建-issue"><a href="#自动创建-issue" class="headerlink" title="自动创建 issue"></a>自动创建 issue</h3><p>对于不能自动创建 issue 的情况，我当然不能忍（因为创建 issue 很麻烦），于是我翻阅资料，终于在 CSDN 上找到一篇文章介绍如何<a href="https://daihaoxin.github.io/post/322747ae.html" target="_blank" rel="noopener">自动创建 issue</a>。</p><p>根据上面文章的介绍，依葫芦画瓢，简单分为以下几个步骤（具体内容请翻看下面的文章）</p><blockquote><p><a href="https://daihaoxin.github.io/post/322747ae.html" target="_blank" rel="noopener">nodejs 版本的 Gitalk/Gitment 评论自动初始化</a></p></blockquote><ul><li><p>生成 sitemap 站点地图</p></li><li><p>获取 github 接口的调用权限</p></li><li><p>安装依赖包</p></li><li><p>创建脚本文件</p></li><li><p>调用脚本</p></li></ul><p>由于上文详细的介绍了每个步骤，这里就不重复介绍。</p><p>但是依照上面的步骤，根据上文的脚本代码运行脚本会报错</p><p>报错信息如下</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/error.png" alt="error"></p><p>报错信息很简单，找不到 find 函数。</p><p>思考一下 find 函数，find 函数是数组才有的方法，如果找不到这个函数，就意味着 issues 并不是一个数组（实际上去打印 issues 会发现它其实一个对象）</p><p>考虑到源代码后续的方法问题，因此，我们只需要加上下面这句话</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!issues.length) issues = []</span><br></pre></td></tr></table></figure><p>更新完毕之后的脚本代码如下</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/fix.png" alt="code"></p><p>然后我们保存 comment.js 文件</p><p>确认依赖安装完毕，然后我们执行以下脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; node comment.js</span><br></pre></td></tr></table></figure><p>顺利的话这个时候，运行结果应该和下图类似</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/issue.png" alt="运行成功"></p><p>为了方便起见，我们也可以在 package.json 里面加上下面的脚本，方便以后一键式进行博客的测试部署</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "push": "hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; node comment.js",</span><br><span class="line">    "dev": "hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>至此，我们大功告成。成功之后点开博客，会发现博客末尾自动开启了 issue</p><p><img src="//jdeseva.github.io/2019/08/08/Hexo更换主题-部署-自动开启issue评论/comment.png" alt="评论区"></p><blockquote><p>可能会出现提示还未初始化的问题，这个时候只需要点击一下登录按钮，进行登录即可显示出评论区。<br>此问题会有概率出现，可能是 github 服务器问题或者国内网络问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui 表格滚动条插件</title>
      <link href="/2019/08/07/element-ui-%E8%A1%A8%E6%A0%BC%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/08/07/element-ui-%E8%A1%A8%E6%A0%BC%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义-element-ui-表格滚动条插件"><a href="#自定义-element-ui-表格滚动条插件" class="headerlink" title="自定义 element-ui 表格滚动条插件"></a>自定义 element-ui 表格滚动条插件</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>此文原发表于本人 CSDN，此文为 2019.08.07 最新迁移与修订。</p></blockquote><p>elemtent-ui 是基于 vue2.0 开发的优秀的 前端 UI 组件库，它秉着 简洁，快速，效率的原则，大大的方便了网站开发人员，减少了开发人员大量的书写组件时间。</p><p>但是 element-ui 中的部分组件，并不能满足所有的开发（<del>产品</del> ）需求，比如 element-ui 中的 表格组件(el-table)，其表格组件功能很强大，但是当表格超出定义宽度之后出现的横向滚动条（浏览器默认滚动条）会影响整体页面美观，如下图</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312155448544.png" alt="来自element-ui官方文档"></p><a id="more"></a><p>可能这个滚动条 已经让不少前端同学（<del>祭了天</del> ）头疼，但是相应的我们联想到 element-ui 也提供了一个隐藏的滚动条组件（<del>滑稽</del> ），如下图</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312155801150.png" alt="垂直滚动条"></p><p>横向的官方文档上有个 bug 例子</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312155925313.png" alt="横向滚动条"></p><p>可以看到，这边原生滚动条和 element-ui 提供的滚动条组件产生了冲突（原因等等会讲，略微提一下解决方案是修改样式）</p><h3 id="需求-amp-解决方案"><a href="#需求-amp-解决方案" class="headerlink" title="需求&amp;解决方案"></a>需求&amp;解决方案</h3><p>某一天我接到了个需求，把表格横向滚动条（主要是横向），改成 el-scrollbar 样子的，于是我正常调用 el-scrollbar 对表格结构进行包裹，结果如下</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312160350274.png" alt="代码片段"></p><p>结果如下</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312160456290.png" alt="结果图"></p><p>（<del>于是我枯了</del> ）</p><p>很显然，这样子并不行，那我们找找原因，为什么不行。打开控制台，可以看出相应的 DOM 节点已经生成，所以必然是样式问题导致（为什么会有样式问题？等等解释）</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/2019031216073775.png" alt="HTML"></p><p>我们选中横向滚动条，发现它的 opacity 是 0</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/2019031216085174.png" alt="el-scrollbar"></p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312160904624.png" alt="CSS"></p><p>为什么会没有？其实很简单，原因是内部 DOM 节点的宽度接近于 el-scrollbar 初始化计算出来的宽度，导致 el-scrollbar 这个组件认为宽度不需要显示，而当窗口变化以后，宽度计算就交给了浏览器。</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312161639816.png" alt="el-scrollbar"></p><p>可以看出这边表格的显示宽度只有 364，只要解决了这个问题，就可以显示出滚动条，那么有什么办法使表格就以实际宽度显示在 DOM 中？（超出部分自动 overflow:hidden）</p><p>翻看资料加上自己的理解，目前主要有 2 个解决方案</p><ul><li><p>重新计算 el-table 的实际宽度，当前节点渲染计算等全都是交给了浏览器进行计算，我们只需要手动计算 el-table 的真实宽度并赋值给对应节点，那么 el-scrollbar 就会进行再次计算进而显示滚动条</p></li><li><p>使用 css3 width 的新属性 fit-content ，即宽度适应内容，具体内容可以移步 <a href="https://www.w3cschool.cn/doc_css/css-fit-content.html" target="_blank" rel="noopener">fit-content</a>，不重复介绍。此属性目前在 IE 上未实现（<del>估计将来也不会</del> ）</p></li></ul><p>并且在以上解决方案时，必须将原生的滚动条取消，否则样式重叠会很难看</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/2019031216334178.png" alt="CSS样式"><br>（.elTableBar 是父层样式选择器）</p><p>有了以上的解决方案，于是我就利用 el-scrollbar 组件进行二次封装，完成了现在的 el-table 滚动条插件（已经兼容各种浏览器，由于 IE 内核手动计算，对性能有一定影响）</p><h4 id="安装-amp-使用"><a href="#安装-amp-使用" class="headerlink" title="安装&amp;使用"></a>安装&amp;使用</h4><p>安装方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i el-table-bar-base</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add el-table-bar-base</span><br></pre></td></tr></table></figure><p>使用方法如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ElTableBar <span class="keyword">from</span> <span class="string">'el-table-bar-base'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'el-table-bar-base/lib/ElTableBar.css'</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElTableBar)</span><br></pre></td></tr></table></figure><p>模板语法如下</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312162524237.png" alt="模板语法"></p><p>效果图</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190312162603466.png" alt="效果图"></p><p>同时 还支持 fixed 模式（此模式感谢 <a href="https://github.com/suchenglin2017" target="_blank" rel="noopener">suchenglin2017</a> 提出的 <a href="https://github.com/JdesEva/el-table-bar-base/issues/2" target="_blank" rel="noopener">issue</a>）</p><p>具体如下</p><p><img src="//jdeseva.github.io/2019/08/07/element-ui-表格滚动条插件/20190713134540164.png" alt="fixed 模式"></p><p>即滚动条跟随屏幕</p><p>具体可以查看<a href="https://github.com/JdesHZ/el-table-bar-base" target="_blank" rel="noopener">el-table-bar-base</a>获得支持。</p><p>愉快的进行撸代码之旅吧！<del>~</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> frame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multiply Strings (大数相乘)</title>
      <link href="/2019/08/05/Multiply-Strings/"/>
      <url>/2019/08/05/Multiply-Strings/</url>
      
        <content type="html"><![CDATA[<h2 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a>Multiply Strings</h2><p>Multiply Strings 译作字符串相乘，取自 LeetCode 算法训练第 43 题（<a href="https://leetcode-cn.com/problems/multiply-strings/solution/" target="_blank" rel="noopener">Multiply Strings</a>），它还有个更加直白的称呼，叫做“大数相乘”。</p><p>此题的背景是因为计算机编程语言对于数字实现的进度缺陷和不足进而衍生出来的一道算法题，众所周知，JavaScript 的数字实现是基于 IEEE754 数值标准。在此标准下，会出现以下几种情况</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false 原因是 0.1 + 0.2 = 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br></pre></td></tr></table></figure><p>以上是对于浮点数而言，原因是 JavaScript 的数值标准只能最高显示 17 位的浮点精度。对于整数，依旧有这个问题，整数的显示进度是 10^20</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span> * <span class="number">10000000000000000</span> * <span class="number">10</span> = <span class="number">100000000000000000000</span> <span class="comment">// 20个0</span></span><br><span class="line"><span class="number">1000</span> * <span class="number">10000000000000000</span> * <span class="number">100</span> = <span class="number">1e+21</span></span><br></pre></td></tr></table></figure><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>以上讲的大概是精度问题，对于数值范围也是会影响到运算，JavaScript 并不能保存所有的数值，他有几个属性，表示数值范围。</p><a id="more"></a><ul><li>Number.MIN_VALUE 能保存的最小数值，在大多数的浏览器里面是 5e-324</li><li>Number.MAX_VALUE 能保存的最大数值，在大多数的浏览器里面是 1.7976931348623157e+308</li></ul><p>任何超出范围的数值，都会被转化为 Infinity 和 -Infinity</p><p>当然，ES6 还新增了两个基本数值范围</p><ul><li>Number.MAX_SAFE_INTEGER 值是 9007199254740991</li><li>Number.MIN_SAFE_INTEGER 值是-9007199254740991</li></ul><p>顾名思义，安全整数范围。</p><h3 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h3><p>假设我们有两个很大数字（整数，简单一点，不考虑小数点）相乘，例如 224524532453453 * 345345345345324534534，在 js 中很明显，会得到指数型的结果 7.753850219863525e+34，但是我们需要得到正确的结果（77538502198635252387237634246045902）该怎么办？</p><p>思考一下乘法定律，例如 55 _ 68 = (50 + 5) _ (60 + 8) = (5 _ 10 + 5) _ (6 * 10 + 8)<br>接着思考一下小学时候我们学过的竖式运算</p><p><img src="//jdeseva.github.io/2019/08/05/Multiply-Strings/multipy.png" alt="竖式运算"></p><p>我们可以得到以下的普适方法：</p><ul><li>申请一个数组，长度是两个数的<strong>长度减 1</strong>(为什么减 1？等等会说)</li><li>两层 for 循环(或 while)，然后每个数字对应的每个位上两两相乘，然后填入对应索引值相加的数组位中</li><li><strong>从右向左循环</strong>，缝 10 进位，累加结果</li></ul><p><del>似乎跳跃有点大</del>，我们在说一个简单通俗一点的方法。</p><ul><li>申请一个空数组用来缓存中间结果</li><li>2 层循环<strong>右端对齐</strong>，使两两对应位数字相乘，然后把结果<strong>unshift</strong>（<strong>push</strong>也可以）进空数组中</li><li>使用<strong>reduce</strong>(push 对应使用<strong>reduceRight</strong>),进行累加，每一次累加，把结果的个位取出，同时保留其他位，<strong>并降位 1</strong>，进入下一轮</li><li>将每一轮的结果都放在上一轮的前面，即可得出结果</li></ul><p>接下来我们用代码实现上面的过程(仅完成第一种方法，第二种方法时间复杂度过高，变成了 O(n^3)，仅仅适用于理解，个人实测解题时间基本在 2000ms 以上（311 个实例）)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">num2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 === <span class="string">'0'</span> || num2 === <span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">'0'</span> <span class="comment">// 处理边界情况</span></span><br><span class="line">  <span class="keyword">var</span> l1 = num1.length,</span><br><span class="line">    l2 = num2.length</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="built_in">Array</span>(l1 + l2 - <span class="number">1</span>).fill(<span class="number">0</span>) <span class="comment">// 缓存中间结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两两相乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l1; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; l2; j++) &#123;</span><br><span class="line">      list[i + j] += num1[i] * num2[j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> t = <span class="number">0</span>,</span><br><span class="line">    r = <span class="string">''</span> <span class="comment">// 累加</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> k = list.length <span class="comment">// 之前说的为什么要数组长度减1的目的就在这里，可以减少一次循环</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    t += list[k]</span><br><span class="line">    r = (t % <span class="number">10</span>) + r <span class="comment">// 当前位的准确结果</span></span><br><span class="line">    t = (t / <span class="number">10</span>) | <span class="number">0</span> <span class="comment">// 前面几位，进位值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> t &gt; <span class="number">0</span> ? t + r : r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是常规方法，也是 LeetCode 主推的方法，此方法的运算时间应该是最快的。具体得看 LeetCode，正常会在 120ms 以内。</p><p>算法还是靠多谢多练。要悟才行。。贴一张我解答此题的提交记录</p><p><img src="//jdeseva.github.io/2019/08/05/Multiply-Strings/pic.png" alt="提交记录"></p><p>错了并不可怕，慢慢悟就行了。急不得，熟能生巧~</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily Notes</title>
      <link href="/2019/08/05/Daily-Notes/"/>
      <url>/2019/08/05/Daily-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Daily-Notes"><a href="#Daily-Notes" class="headerlink" title="Daily Notes"></a>Daily Notes</h2><p>这篇博客是日常笔记，仅仅用作学习参考。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li>core-js 目标是是 ES Next，e5s-shim 是对 ES5 进行兼容，例如 bind 的实现，e5s-shim 对 Function.length 进行了模拟。（感谢 Lucas 老师解答）</li><li>AOP 面向切面编程</li><li>表达式也有返回值</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios Interceptors and CancelToken</title>
      <link href="/2019/08/01/axios-Interceptors-and-CancelToken/"/>
      <url>/2019/08/01/axios-Interceptors-and-CancelToken/</url>
      
        <content type="html"><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios 是目前前端常用的 HTTP 请求框架，地位几乎等同于几年前的 jQuery 的 ajax。为什么 axios 现在这么多人使用，笔者看来大概是因为一下几个方面</p><ul><li>前端模块化的大势所趋</li><li>axios 很多强大的功能特性</li><li>Promise 的普及</li></ul><p>个人认为以上三点是最主要的原因，下面切入正题，本文将对笔者在实际开发中关于 axios 的 Interceptors 和 CancelToken 做一个简单的阐述。</p><h4 id="Interceptors-拦截器"><a href="#Interceptors-拦截器" class="headerlink" title="Interceptors 拦截器"></a>Interceptors 拦截器</h4><p>axios 的 Interceptors(拦截器，以下统称拦截器)，应该说是 axios 最为强大的功能之一，尽管 jQuery 的 ajax 也可以使用拦截器（jQuery 中 ajax 的 beforeSend 方法），但是它只能对单个请求进行拦截，无法做到统一配置。</p><p>前端开发是本着代码简短强悍（<del>lazy</del>）为目标的，因此能够统一配置拦截器的 axios 自然受到了开发者的追捧。</p><p>拦截器分为两种，分别是 request 拦截器和 response 拦截器，顾名思义，分别作用于一个 http 请求的 request 阶段（之前）和 response 阶段（拿回响应进行回调之前）。</p><a id="more"></a><p>大致用法如下</p><p>request 拦截器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http request 拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>response 拦截器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http response 拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error) <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以上大概很多开发者都会使用，下面我们着重说一下 axios 的 CancelToken</p><h4 id="CancelToken"><a href="#CancelToken" class="headerlink" title="CancelToken"></a>CancelToken</h4><p>CancelToken，字面意思的取消一个 Token 令牌。它的作用和 jQuery 中 ajax 的 abort 效果是一样的，就是掐掉这个请求。</p><p>可能会有笔者会问，axios 是基于 Promise 实现的，Promise 状态一但确立，不是不能改变吗（就是说不能取消一个进行中的 Promise，让它既不能 resolve，也不能 reject）？</p><p>这个问题，得回到 Promise 的 T39 对于 Promise/A+的提案上去（<a href="https://promisesaplus.com/" target="_blank" rel="noopener">关于 Promise/A+</a>）</p><p>因为 T39 协会想的是 Promise 既然是一个状态机，那么必然应有且只有 2 中状态，Yes or No，对应 resolve 和 reject（注意这里说的是状态，不是方法）</p><p>其实社区对于 Promise 的 cancel 是有一个提案的（已经被撤回），具体参考<a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">proposal-cancelable-promises</a></p><p>尽管该提案已经被撤回，不再参与 T39 对于 Promise 的提案，但是不妨碍社区对它的实现。axios 的 CancelToken 便是基于此实现的。</p><p>下面是一个简单的 CancelToken</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cancel</span><br><span class="line"></span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    cancel = fn</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当上面那个请求还在Pending时，我们可以这样子调用</span></span><br><span class="line"></span><br><span class="line">cancel() <span class="comment">//取消请求</span></span><br></pre></td></tr></table></figure><p>上面这样子使用是对于单个请求而言，接下来我们考虑一种比较极端的情况。一个按钮，提交一次表单，然后我们在瞬时间连续按了 N 次，最坏的情况，按钮没有加防抖函数（Debounce），也没有使用按钮 Loading。那么，势必会向后台请求 N 次。</p><p>这个例子可能并不是很好，笔者再说一个特殊情况。</p><p>有一个查询请求，数据量比较大，需要 pending 比较久的时间，再这个过程中，用户通过切换 Tab 页重复查询了。那么 axios 的请求队列中就会有 2 个一模一样的请求在进行，实际上而言，我们需要的仅仅只是一个（本着先来先用的原则，可能只需要之前的那个就行）。这个时候我们为了不浪费网络资源，需要的就是掐掉那个一模一样的，但是是后面来的请求。</p><p>上面这种情况就需要我们在拦截器中进行拦截，拦截重复请求，然后进行 CancelToken。</p><p>先分析怎么实现，因为需要判断重复请求，所以需要思考怎么样的才算重复请求。笔者这边比较偷懒，判断 url + data。两者一模一样，即判定为重复请求</p><p>首先是在 request 拦截器里面进行部署 axios 的 CancelToken</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pending = [] <span class="comment">// 请求队列</span></span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken <span class="comment">// axios abort</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http request 拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    removePending(config) <span class="comment">// 移除重复的请求</span></span><br><span class="line">    <span class="comment">// 部署 abort</span></span><br><span class="line">    <span class="keyword">var</span> uid = config.data ? <span class="built_in">JSON</span>.stringify(config.data) : <span class="string">'undefined'</span></span><br><span class="line">    config.cancelToken = <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      pending.unshift(&#123; <span class="attr">url</span>: config.url, <span class="attr">cancel</span>: fn, <span class="attr">uid</span>: uid &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这边仅仅是一个例子，如果实际需求中提交是用 application/x-www-form-urlencoded 提交。那完全可以在 request 中使用 qs 模块，进行 qs.stringify 之后将序列化之后的请求体作为 uid，一举两得。</p><p>然后我们在构造一个移除重复请求的函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数,移除已经完成的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> removePending = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> uid = ev.data ? <span class="built_in">JSON</span>.stringify(ev.data) : <span class="string">'undefined'</span></span><br><span class="line">  <span class="built_in">console</span>.log(uid)</span><br><span class="line">  <span class="keyword">var</span> index = pending.findIndex(<span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ev.url.indexOf(row.url) &gt; <span class="number">-1</span> &amp;&amp; uid === row.uid</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    pending[index].cancel()</span><br><span class="line">    pending.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步，则是在 response 拦截器中，对于已经完成的请求进行移除</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http response 拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    removePending(response.config) <span class="comment">// 请求成功则移出请求队列</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">      removePending(error.response.config)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error) <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然上面代码有需要优化的地方（就留给大家啦），而 CancelToken 仅仅是在除去重复请求的方法的保底措施，实际中，大家还是尽量以 Loading，防抖函数为主。是否部署 CancelToken 应该是以具体的项目为准，切不可盲目部署，毕竟每一次请求之后都需要循环去 find 是否有重复请求，对于性能而言会有一点影响。</p>]]></content>
      
      
      
        <tags>
            
            <tag> frame </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
